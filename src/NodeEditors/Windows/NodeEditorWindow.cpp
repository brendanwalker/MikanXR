//-- includes -----
#include "NodeEditorWindow.h"
#include "Logger.h"

#include "AssetReference.h"
#include "GlCommon.h"
#include "GlModelResourceManager.h"
#include "GlStateStack.h"
#include "GlShaderCache.h"
#include "GlTexture.h"
#include "Graphs/NodeGraph.h"
#include "Graphs/NodeEvaluator.h"
#include "Nodes/Node.h"
#include "PathUtils.h"
#include "SdlManager.h"
#include "SdlWindow.h"
#include "StringUtils.h"
#include "TextStyle.h"

#include "Pins/NodePin.h"

#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "backends/imgui_impl_sdl.h"
#include "backends/imgui_impl_opengl3.h"

#include "imnodes.h"

// Autogenerated header containing Unicode Icon IDs from "forkawesome-webfont.ttf"
#include "IconsForkAwesome.h"

#include "tinyfiledialogs.h" // Cross-platform file dialogs library

#include <easy/profiler.h>

#include "glm/ext/vector_float4.hpp"

// Drag-Drop Payload Types
#define DRAG_DROP_TYPE_VARIABLE		"Variable"
#define DRAG_DROP_TYPE_ASSET_REF	"Asset"

//-- public methods -----
NodeEditorWindow::NodeEditorWindow()
	: m_sdlWindow(SdlWindowUniquePtr(new SdlWindow))
	, m_glStateStack(GlStateStackUniquePtr(new GlStateStack))
	, m_modelResourceManager(GlModelResourceManagerUniquePtr(new GlModelResourceManager))
	, m_shaderCache(GlShaderCacheUniquePtr(new GlShaderCache))
{}

NodeEditorWindow::~NodeEditorWindow()
{
}

GlLineRenderer* NodeEditorWindow::getLineRenderer()
{
	return nullptr;
}

GlTextRenderer* NodeEditorWindow::getTextRenderer()
{
	return nullptr;
}

GlModelResourceManager* NodeEditorWindow::getModelResourceManager()
{
	return m_modelResourceManager.get();
}

GlShaderCache* NodeEditorWindow::getShaderCache()
{
	return m_shaderCache.get();
}

GlStateStack& NodeEditorWindow::getGlStateStack()
{
	return *m_glStateStack.get();
}

SdlWindow& NodeEditorWindow::getSdlWindow()
{
	return *m_sdlWindow.get();
}

bool NodeEditorWindow::startup()
{
	EASY_FUNCTION();

	bool success = true;

	MIKAN_LOG_INFO("NodeEditorWindow::init()") << "Initializing NodeEditorWindow";

	static const int k_node_window_pixel_width = 1080;
	static const int k_node_window_pixel_height = 720;

	auto windowTitle = "Node Editor";
	m_sdlWindow
		->enableGLDataSharing() // Want access to video textures owned by MainWindow's GL Context
		->setTitle(windowTitle)
		->setSize(k_node_window_pixel_width, k_node_window_pixel_height);
	if (!m_sdlWindow->startup())
	{
		MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize main SDK window: ";
		success = false;
	}

	// Setup ImGui context
	if (success)
	{
		// Setup ImGui context
		IMGUI_CHECKVERSION();
		m_imguiContext = ImGui::CreateContext();
		if (m_imguiContext != NULL)
		{
			configImGui();
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to create imgui context";
			success = false;
		}
	}

	// Setup ImGui SDL backend
	if (success)
	{
		if (ImGui_ImplSDL2_InitForOpenGL(
			m_sdlWindow->getInternalSdlWindow(),
			m_sdlWindow->getInternalGlContext()))
		{
			m_imguiSDLBackendInitialised= true;
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize imgui SDL backend";
			success = false;
		}
	}

	// Setup ImGui OpenGL backend
	const std::string& glsl_version= SdlManager::getInstance()->getGlslVersion();
	if (success)
	{
		if (ImGui_ImplOpenGL3_Init(glsl_version.c_str()))
		{
			m_imguiOpenGLBackendInitialised= true;
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize imgui openGL backend";
			success = false;
		}
	}

	// Setup the ImNodes context
	if (success)
	{
		m_imnodesContext = ImNodes::CreateContext();
		if (m_imnodesContext != nullptr)
		{
			configImNodes();
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to create imnodes context";
			success = false;
		}
	}

	if (success && !m_shaderCache->startup())
	{
		MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Failed to initialize shader cache!";
		success = false;
	}

	if (success)
	{
		if (!m_modelResourceManager->startup())
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::init") << "Unable to initialize model resource manager";
			success = false;
		}
	}

	if (success)
	{
		static const glm::vec4 k_clear_color = glm::vec4(0.45f, 0.45f, 0.5f, 1.f);

		glClearColor(k_clear_color.r, k_clear_color.g, k_clear_color.b, k_clear_color.a);
		glViewport(0, 0, m_sdlWindow->getWidth(), m_sdlWindow->getHeight());

		// Set default state flags at the base of the stack
		m_glStateStack->pushState()
			.enableFlag(eGlStateFlagType::light0)
			.enableFlag(eGlStateFlagType::texture2d)
			.enableFlag(eGlStateFlagType::depthTest)
			.disableFlag(eGlStateFlagType::cullFace)
			// This has to be enabled since the point drawing shader will use gl_PointSize.
			.enableFlag(eGlStateFlagType::programPointSize);
	}

	return success;
}

void NodeEditorWindow::render()
{
	EASY_FUNCTION();

	// Clear the window
	m_sdlWindow->renderBegin();

	// Tell ImGui to prepare for a new frame
	ImGui_ImplOpenGL3_NewFrame();
	ImGui_ImplSDL2_NewFrame();
	ImGui::NewFrame();

	// Draw the current state if the editor window
	m_isRenderingUI = true;
	renderUI();
	m_isRenderingUI = false;

	// Tell ImGui to render the UI draw commands to the GL context
	ImGui::Render();
	glViewport(0, 0, (int)getWidth(), (int)getHeight());
	ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

	// Call SDL_GL_SwapWindow
	m_sdlWindow->renderEnd();
}


void NodeEditorWindow::renderUI()
{
	pushImGuiStyles();

	ImGui::SetNextWindowSize(ImVec2(getWidth(), getHeight()), ImGuiCond_Once);
	ImGui::Begin("Node Editor");

		// Toolbar
		renderToolbar();

		// Left Panel
		renderGraphVariablesPanel();

		ImGui::SameLine();
		ImGui::BeginChild("Main Panel", ImVec2(ImGui::GetContentRegionAvail().x - 250,
											   ImGui::GetContentRegionAvail().y));
			// Main Frame
			renderMainFrame();

			// Bottom Panel
			renderAssetsPanel();

		ImGui::EndChild();

		// Right Panel
		renderSelectedObjectPanel();

	ImGui::End();

	popImGuiStyles();
}

void NodeEditorWindow::renderMainFrame()
{
	NodeGraphPtr nodeGraph= getNodeGraph();

	ImGui::BeginChild("Main", ImVec2(ImGui::GetContentRegionAvail().x,
									 ImGui::GetContentRegionAvail().y - 226));

	ImNodes::BeginNodeEditor();

	if (nodeGraph)
	{
		nodeGraph->editorRender(m_editorState);
	}

	ImNodes::EndNodeEditor();
	ImGui::EndChild();

	// Node selection
	if (ImNodes::NumSelectedNodes() > 0)
	{
		GraphObjectSelection selection(GraphObjectIdType::NODE, ImNodes::NumSelectedNodes());

		ImNodes::GetSelectedNodes(selection.getRawObjectArray());
		m_objectSelection= selection;
	}

	// Start link
	if (ImNodes::IsLinkStarted(&m_editorState.startedLinkPinId))
	{
		NodePinPtr pinPtr= getNodeGraph()->getPinById(m_editorState.startedLinkPinId);
		if (pinPtr)
		{
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = pinPtr->editorGetLinkStyleColor();
		}
	}

	// Drop link
	if (ImNodes::IsLinkDropped())
	{
		ImGui::OpenPopup("editor_context_menu_nodes");
		m_editorState.bLinkHanged = true;
		m_editorState.hangPos = ImGui::GetMousePos();
	}

	// Link creation
	int startPinId, endPinId;
	if (ImNodes::IsLinkCreated(&startPinId, &endPinId))
	{
		m_editorState.startedLinkPinId = -1;
		getNodeGraph()->createLink(startPinId, endPinId);
	}

	// Context menu
	renderMainFrameContextMenu(m_editorState);

	// Drag and drop creation
	{
		NodeEditorState editorStateCopy = m_editorState;
		editorStateCopy.hangPos = ImGui::GetMousePos();

		handleMainFrameDragDrop(editorStateCopy);
	}

	// Delete key event
	if (ImGui::IsKeyPressed(ImGuiKey_Delete, false))
	{
		deleteSelectedItem();
	}
}

void NodeEditorWindow::renderMainFrameContextMenu(const NodeEditorState& editorState)
{
	if (ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).x == 0.0f
		&& ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).y == 0.0f
		&& ImGui::IsMouseReleased(ImGuiMouseButton_Right)
		&& ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows))
	{
		int id = -1;
		if (ImNodes::IsNodeHovered(&id))
		{
			ImNodes::ClearNodeSelection();
			ImNodes::ClearLinkSelection();
			ImNodes::SelectNode(id);
			m_objectSelection= GraphObjectSelection(GraphObjectIdType::NODE, 1);
			m_objectSelection.setObjectId(0, id);
			ImGui::OpenPopup("editor_context_menu_node");
		}
		else if (ImNodes::IsLinkHovered(&id))
		{
			ImNodes::ClearNodeSelection();
			ImNodes::ClearLinkSelection();
			ImNodes::SelectLink(id);
			m_objectSelection = GraphObjectSelection(GraphObjectIdType::LINK, 1);
			m_objectSelection.setObjectId(0, id);
			ImGui::OpenPopup("editor_context_menu_link");
		}
		else
		{
			ImGui::OpenPopup("editor_context_menu_nodes");
			m_editorState.hangPos = ImGui::GetMousePos();
		}
	}

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	if (ImGui::BeginPopup("editor_context_menu_node"))
	{
		NodePtr node;
		if (m_objectSelection.getObjectIdType() == GraphObjectIdType::NODE)
		{
			node= getNodeGraph()->getNodeById(m_objectSelection.getObjectId(0));
		}

		if (node && node->editorCanDelete())
		{
			if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
			{
				getNodeGraph()->deleteNodeById(m_objectSelection.getObjectId(0));
			}
		}
		else
		{
			ImGui::CloseCurrentPopup();
		}
		ImGui::EndPopup();
	}
	else if (ImGui::BeginPopup("editor_context_menu_link"))
	{
		if (m_objectSelection.getObjectIdType() == GraphObjectIdType::LINK &&
			ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
		{
			getNodeGraph()->deleteLinkById(m_objectSelection.getObjectId(0));
		}
		ImGui::EndPopup();
	}
	else if (ImGui::BeginPopup("editor_context_menu_nodes"))
	{
		NodeGraphPtr nodeGraph= getNodeGraph();
		if (nodeGraph)
		{
			std::vector<NodeFactoryPtr> nodeFactories = getNodeGraph()->editorGetValidNodeFactories(editorState);
			for (NodeFactoryPtr nodeFactory : nodeFactories)
			{
				const std::string nodeTitle = nodeFactory->getNodeDefaultObject()->editorGetTitle();

				if (ImGui::MenuItem(nodeTitle.c_str()))
				{
					getNodeGraph()->createNode(nodeFactory, editorState);
					break;
				}
			}
		}
		ImGui::EndPopup();
	}
	else if (m_editorState.bLinkHanged)
	{
		m_editorState.bLinkHanged = false;
		m_editorState.startedLinkPinId = -1;
	}
	ImGui::PopStyleColor(2);
	ImGui::PopStyleVar(3);
}

void NodeEditorWindow::renderToolbar()
{
	ImGui::PushFont(m_BigIconFont);

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0);
	ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	ImGui::BeginChild("Toolbar", ImVec2(ImGui::GetContentRegionAvail().x, 40));

	ImGui::SetCursorPosY((ImGui::GetWindowHeight() - 30) * 0.5f);
	if (ImGui::Button(ICON_FK_FLOPPY_O "   Save", ImVec2(0, 30)))
	{
		saveGraph(false);
	}

	// Editor Control
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 4.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 4));
		ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));

		ImGui::SameLine();
		ImGui::BeginChild("EditorControl", ImVec2(70, 30), true, ImGuiWindowFlags_NoScrollbar);
		ImGui::SetCursorPosY((ImGui::GetWindowHeight() - ImGui::GetTextLineHeight()) * 0.5f);

		ImGui::SameLine();
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
		if (ImGui::SmallButton(ICON_FK_UNDO))
		{
			undo();
		}
		ImGui::PopStyleColor();

		ImGui::EndChild();
		ImGui::PopStyleColor(3);
		ImGui::PopStyleVar(2);
	}

	ImGui::EndChild();

	ImGui::PopStyleVar(3);
	ImGui::PopStyleColor(4);

	ImGui::PopFont();
}

void NodeEditorWindow::renderGraphVariablesPanel()
{
	ImGui::BeginChild("Left Panel", ImVec2(200, ImGui::GetContentRegionAvail().y));


	// Title bar
	ImGui::SetNextItemOpen(true, ImGuiCond_Once);
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
	ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	bool isNodeOpened = ImGui::CollapsingHeader("Variables", ImGuiTreeNodeFlags_SpanAvailWidth);
	ImGui::PopStyleVar(3);
	ImGui::PopStyleColor(3);

	if (isNodeOpened)
	{
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));

		auto propertyMap = getNodeGraph()->getPropertyMap();
		for (auto it = propertyMap.begin(); it != propertyMap.end(); it++)
		{
			t_graph_property_id propertyId = it->first;
			GraphPropertyPtr variable = it->second;

			// Variable
			const std::string varIcon = variable->editorGetIcon();
			const ImVec4& variconColor = variable->editorGetIconColor();
			ImGui::TextColored(variconColor, varIcon.c_str());
			ImGui::SameLine();

			const std::string varEntryName =
				StringUtils::stringify(
					variable->getName(), "##property", std::to_string(propertyId));
			bool isSelected = m_objectSelection.getObjectIdType() == GraphObjectIdType::VARIABLE;
			isSelected = isSelected && (m_objectSelection.getObjectId(0) == variable->getId());
			if (ImGui::Selectable(varEntryName.c_str(), &isSelected))
			{
				ImNodes::ClearLinkSelection();
				ImNodes::ClearNodeSelection();
				if (isSelected)
				{
					m_objectSelection = GraphObjectSelection(GraphObjectIdType::VARIABLE, 1);
					m_objectSelection.setObjectId(0, variable->getId());
				}
				else
				{
					m_objectSelection.clear();
				}
			}
			if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
			{
				ImGui::SetDragDropPayload(
					variable->getClassName().c_str(), &variable, sizeof(GraphPropertyPtr));
				ImGui::Text(variable->getName().c_str());
				ImGui::EndDragDropSource();
			}

			// Context menu
			ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
			ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
			if (ImGui::BeginPopupContextItem())
			{
				ImNodes::ClearLinkSelection();
				ImNodes::ClearNodeSelection();
				m_objectSelection = GraphObjectSelection(GraphObjectIdType::VARIABLE, 1);
				m_objectSelection.setObjectId(0, variable->getId());

				if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
				{
					getNodeGraph()->deletePropertyById(propertyId);
					m_objectSelection.clear();
				}

				ImGui::EndPopup();
			}
			ImGui::PopStyleColor(2);
			ImGui::PopStyleVar(3);
		}
		ImGui::PopStyleColor();
	}

	renderNewGraphVariablesContextMenu(m_editorState);

	ImGui::EndChild();
}

void NodeEditorWindow::renderNewGraphVariablesContextMenu(const NodeEditorState& editorState)
{
	// Don't show context menu if a variable is selected
	if (m_objectSelection.hasSelectionOfType(GraphObjectIdType::VARIABLE))
		return;

	if (ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).x == 0.0f
		&& ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).y == 0.0f
		&& ImGui::IsMouseReleased(ImGuiMouseButton_Right)
		&& ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows))
	{
		ImGui::OpenPopup("editor_context_menu_nodes");
	}

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	if (ImGui::BeginPopup("editor_context_menu_nodes"))
	{
		NodeGraphPtr nodeGraph = getNodeGraph();
		if (nodeGraph)
		{
			std::vector<GraphPropertyFactoryPtr> propertyFactories = 
				getNodeGraph()->editorGetValidPropertyFactories(editorState);

			for (GraphPropertyFactoryPtr propertyFactory : propertyFactories)
			{
				const std::string propertyTitle = propertyFactory->getDefaultGraphPropertyObject()->editorGetTitle();

				if (ImGui::MenuItem(propertyTitle.c_str()))
				{
					GraphPropertyPtr newVariable= getNodeGraph()->createProperty(propertyFactory);

					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();

					m_objectSelection = GraphObjectSelection(GraphObjectIdType::VARIABLE, 1);
					m_objectSelection.setObjectId(0, newVariable->getId());
					break;
				}
			}
		}
		ImGui::EndPopup();
	}
	ImGui::PopStyleColor(2);
	ImGui::PopStyleVar(3);
}

void NodeEditorWindow::renderAssetsPanel()
{
	NodeGraphPtr nodeGraph= getNodeGraph();

	ImGui::BeginChild("Assets Panel", ImVec2(ImGui::GetContentRegionAvail().x, 216));
	if (ImGui::BeginTabBar("AssetsTabBar"))
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
		if (ImGui::BeginTabItem("Assets"))
		{
			ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
			ImGui::BeginChild("AssetSubFrame");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 6, ImGui::GetCursorPos().y + 1));

			if (nodeGraph)
			{
				auto& factoryMap = nodeGraph->getAssetReferenceFactories();
				for (auto it = factoryMap.begin(); it != factoryMap.end(); it++)
				{
					auto& assetRefFactory = it->second;
					const std::string& assetTypeName = assetRefFactory->getAssetTypeName();
					const std::string buttonName = StringUtils::stringify(ICON_FK_PLUS_CIRCLE "  Add ", assetTypeName, "##", assetTypeName);

					if (ImGui::SmallButton(buttonName.c_str()))
					{
						auto assetPath =
							tinyfd_openFileDialog(
								assetRefFactory->getFileDialogTitle(),
								assetRefFactory->getDefaultPath(),
								assetRefFactory->getFilterPatternCount(),
								assetRefFactory->getFilterPatterns(),
								assetRefFactory->getFilterDescription(),
								1);

						if (assetPath)
						{
							std::stringstream ssPaths(assetPath);
							std::string path;
							while (std::getline(ssPaths, path, '|'))
							{
								std::string universalPath(path);
								std::replace(universalPath.begin(), universalPath.end(), '\\', '/');

								// Create the asset reference
								AssetReferencePtr assetRef = assetRefFactory->allocateAssetReference();
								if (assetRef)
								{
									// Assign path to the asset
									assetRef->setAssetPath(universalPath);

									// Register the asset reference with the graph
									nodeGraph->getAssetReferencesMutable().push_back(assetRef);
									onAssetReferenceCreated(assetRef);
								}
							}
						}
					}
					ImGui::SameLine();
				}
			}

			ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 18);
			ImGui::Separator();

			// Assets browser
			if (nodeGraph)
			{
				auto& assetRefArray = nodeGraph->getAssetReferences();

				ImGui::BeginChild("AssetBrowser");

				ImGui::Dummy(ImVec2(1, 10));
				for (int assetIndex = 0; assetIndex < assetRefArray.size(); assetIndex++)
				{
					AssetReferencePtr assetRefPtr= assetRefArray[assetIndex];

					ImGui::Dummy(ImVec2(10, 140));
					ImGui::SameLine();
					ImGui::BeginGroup();
					std::string idStr = "##asset" + std::to_string(assetIndex);
					ImGui::Button(idStr.c_str(), ImVec2(120, 140));

					if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
					{
						ImGui::SetDragDropPayload(
							assetRefPtr->getClassName().c_str(), &assetRefPtr, sizeof(AssetReferencePtr));
						ImGui::Text(assetRefPtr->getShortName().c_str());
						ImGui::EndDragDropSource();
					}

					// Context menu
					bool itemDeleted = false;
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
					ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
					ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
					ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
					if (ImGui::BeginPopupContextItem())
					{
						ImNodes::ClearLinkSelection();
						ImNodes::ClearNodeSelection();

						m_objectSelection = GraphObjectSelection(GraphObjectIdType::ASSET, assetIndex);
						m_objectSelection.setObjectId(0, assetIndex);

						if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						{
							deleteSelectedItem();
							itemDeleted = true;
						}

						ImGui::EndPopup();
					}
					ImGui::PopStyleColor(2);
					ImGui::PopStyleVar(3);

					if (!itemDeleted)
					{
						GlTexturePtr texture= assetRefPtr->getPreviewTexture();

						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10);
						ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 130);

						if (texture && texture->getGlTextureId() != 0)
						{
							ImGui::Image((void*)(intptr_t)texture->getGlTextureId(), ImVec2(100, 100));
						}
						ImGui::Dummy(ImVec2(2, 1));
						ImGui::SameLine();
						ImGui::SetNextItemWidth(108);
						ImGui::Text(assetRefPtr->getShortName().c_str());
					}
					ImGui::EndGroup();

					ImGui::SameLine();
					if (ImGui::GetContentRegionAvail().x < 130)
					{
						ImGui::NewLine();
						ImGui::NewLine();
					}
				}
				ImGui::NewLine();
				ImGui::Dummy(ImVec2(1, 10));

				ImGui::EndChild();
			}

			ImGui::EndChild();
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			ImGui::EndTabItem();
		}
		ImGui::PopStyleVar();
		ImGui::EndTabBar();
	}
	ImGui::EndChild();
}

void NodeEditorWindow::renderSelectedObjectPanel()
{
	ImGui::SameLine();
	ImGui::BeginChild("Right Panel", ImVec2(344, ImGui::GetContentRegionAvail().y));

	if (m_objectSelection.getObjectIdType() == GraphObjectIdType::NODE)
	{
		NodePtr node = getNodeGraph()->getNodeById(m_objectSelection.getObjectId(0));

		if (node)
		{
			node->editorRenderPropertySheet(m_editorState);
		}
	}
	else if (m_objectSelection.getObjectIdType() == GraphObjectIdType::ASSET)
	{
		const int assetIndex= m_objectSelection.getObjectId(0);
		const std::vector<AssetReferencePtr>& assetArray= getNodeGraph()->getAssetReferences();

		if (assetIndex >= 0 && assetIndex < (int)assetArray.size())
		{
			assetArray[assetIndex]->editorRenderPropertySheet(m_editorState);
		}
	}
	else if (m_objectSelection.getObjectIdType() == GraphObjectIdType::VARIABLE)
	{
		GraphPropertyPtr property = getNodeGraph()->getPropertyById(m_objectSelection.getObjectId(0));

		if (property)
		{
			property->editorRenderPropertySheet(m_editorState);
		}
	}

	ImGui::EndChild();
}

void NodeEditorWindow::deleteSelectedItem()
{
	if (m_objectSelection.getObjectIdType() == GraphObjectIdType::NODE)
	{
		for (int i = 0; i < m_objectSelection.getObjectCount(); i++)
		{
			const t_node_id nodeId= m_objectSelection.getObjectId(i);
			NodePtr node= getNodeGraph()->getNodeById(nodeId);

			if (node && node->editorCanDelete())
			{
				getNodeGraph()->deleteNodeById(nodeId);
			}
		}

		m_objectSelection.clear();
	}
	else if (m_objectSelection.getObjectIdType() == GraphObjectIdType::LINK)
	{
		for (int i = 0; i < m_objectSelection.getObjectCount(); i++)
		{
			const t_node_link_id linkId = m_objectSelection.getObjectId(i);

			getNodeGraph()->deleteLinkById(linkId);
		}

		m_objectSelection.clear();
	}
	else if (m_objectSelection.getObjectIdType() == GraphObjectIdType::VARIABLE)
	{
		for (int i = 0; i < m_objectSelection.getObjectCount(); i++)
		{
			const t_graph_property_id propertyId = m_objectSelection.getObjectId(i);

			getNodeGraph()->deletePropertyById(propertyId);
		}

		m_objectSelection.clear();
	}
	else if (m_objectSelection.getObjectIdType() == GraphObjectIdType::ASSET && 
			 m_objectSelection.getObjectCount() > 0)
	{
		std::vector<AssetReferencePtr>& assetList= getNodeGraph()->getAssetReferencesMutable();
		const int assetIndex = m_objectSelection.getObjectId(0);

		assetList.erase(assetList.begin() + assetIndex);
		m_objectSelection.clear();
	}
}

NodeGraphFactoryPtr NodeEditorWindow::getNodeGraphFactory() const 
{ 
	return std::make_shared<NodeGraphFactory>(); 
}

void NodeEditorWindow::newGraph()
{
	m_editorState.nodeGraph= getNodeGraphFactory()->initialCreateNodeGraph(this);
	onNodeGraphCreated();
}

bool NodeEditorWindow::loadGraph(const std::filesystem::path& path)
{
	m_editorState.nodeGraph= NodeGraphFactory::loadNodeGraph(this, path);
	if (m_editorState.nodeGraph)
	{
		m_editorState.nodeGraphPath= path;
		onNodeGraphCreated();
		return true;
	}
	else
	{
		MIKAN_LOG_ERROR("NodeEditorWindow::load") << "Failed to load node graph: " << path;
	}

	return false;
}

bool NodeEditorWindow::saveGraph(bool bShowFileDialog)
{
	// If no path was set or we explicitly want to show the file dialog,
	// bring up the save path dialog
	if (m_editorState.nodeGraphPath.empty() || bShowFileDialog)
	{
		std::string defautPath= (PathUtils::getResourceDirectory() / "graphs" / "new_graph.graph").string();
		const char* filterItems[1] = {"*.graph"};
		const char* filterDesc = "Graph Files (*.graph)";
		auto path = tinyfd_saveFileDialog("Save Compositor Graph", defautPath.c_str(), 1, filterItems, filterDesc);
		if (path)
		{
			m_editorState.nodeGraphPath= path;
		}
	}

	if (!m_editorState.nodeGraphPath.empty() && m_editorState.nodeGraph)
	{
		NodeGraphFactory::saveNodeGraph(m_editorState.nodeGraphPath, m_editorState.nodeGraph);
		return true;
	}

	return false;
}

void NodeEditorWindow::undo()
{
	//TODO
}

void NodeEditorWindow::onNodeGraphCreated()
{
	getNodeGraph()->OnNodeCreated += MakeDelegate(this, &NodeEditorWindow::onNodeCreated);
	getNodeGraph()->OnNodeDeleted += MakeDelegate(this, &NodeEditorWindow::onNodeDeleted);
	getNodeGraph()->OnLinkDeleted += MakeDelegate(this, &NodeEditorWindow::onLinkDeleted);
	getNodeGraph()->OnPropertyCreated += MakeDelegate(this, &NodeEditorWindow::onGraphPropertyCreated);
	getNodeGraph()->OnPropertyModifed += MakeDelegate(this, &NodeEditorWindow::onGraphPropertyModified);
	getNodeGraph()->OnPropertyDeleted += MakeDelegate(this, &NodeEditorWindow::onGraphPropertyDeleted);
}

void NodeEditorWindow::onNodeGraphDeleted()
{
	getNodeGraph()->OnNodeCreated -= MakeDelegate(this, &NodeEditorWindow::onNodeCreated);
	getNodeGraph()->OnNodeDeleted -= MakeDelegate(this, &NodeEditorWindow::onNodeDeleted);
	getNodeGraph()->OnLinkDeleted -= MakeDelegate(this, &NodeEditorWindow::onLinkDeleted);
	getNodeGraph()->OnPropertyCreated -= MakeDelegate(this, &NodeEditorWindow::onGraphPropertyCreated);
	getNodeGraph()->OnPropertyModifed -= MakeDelegate(this, &NodeEditorWindow::onGraphPropertyModified);
	getNodeGraph()->OnPropertyDeleted -= MakeDelegate(this, &NodeEditorWindow::onGraphPropertyDeleted);
}

void NodeEditorWindow::onNodeCreated(t_node_id id)
{
	// Set the initial position of the node using the current editor mouse position
	const ImVec2& hangPos = m_editorState.hangPos;
	ImNodes::SetNodeScreenSpacePos(id, hangPos);
	NodePtr node= getNodeGraph()->getNodeById(id);
	if (node)
	{
		node->setNodePos(glm::vec2(hangPos.x, hangPos.y));
	}

	// Make the newly created node selected
	m_objectSelection = GraphObjectSelection(GraphObjectIdType::NODE, 1);
	m_objectSelection.setObjectId(0, id);

	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(id);

}

void NodeEditorWindow::onNodeDeleted(t_node_id id)
{
	if (m_objectSelection.getObjectIdType() == GraphObjectIdType::NODE &&
		m_objectSelection.removeObjectId(id))
	{
		ImNodes::ClearNodeSelection();
	}
}

void NodeEditorWindow::onLinkDeleted(t_node_link_id id)
{
	if (m_objectSelection.getObjectIdType() == GraphObjectIdType::LINK &&
		m_objectSelection.removeObjectId(id))
	{
		ImNodes::ClearLinkSelection();
	}
}

void NodeEditorWindow::shutdown()
{
	onNodeGraphDeleted();
	m_editorState.nodeGraph= nullptr;
	m_editorState.nodeGraphPath.clear();

	m_glStateStack = nullptr;

	if (m_shaderCache != nullptr)
	{
		m_shaderCache->shutdown();
		m_shaderCache = nullptr;
	}

	if (m_imnodesContext != nullptr)
	{
		ImNodes::DestroyContext(m_imnodesContext);
		m_imnodesContext= nullptr;
	}

	if (m_imguiOpenGLBackendInitialised)
	{
		ImGui_ImplOpenGL3_Shutdown();
		m_imguiOpenGLBackendInitialised = false;
	}

	if (m_imguiSDLBackendInitialised)
	{
		ImGui_ImplSDL2_Shutdown();
		m_imguiSDLBackendInitialised = false;
	}

	if (m_imguiContext != nullptr)
	{
		ImGui::DestroyContext(m_imguiContext);
		m_imguiContext = nullptr;
	}

	if (m_sdlWindow != nullptr)
	{
		m_sdlWindow->shutdown();
		m_sdlWindow = nullptr;
	}
}
 
float NodeEditorWindow::getWidth() const
{
	return (float)m_sdlWindow->getWidth();
}

float NodeEditorWindow::getHeight() const
{
	return (float)m_sdlWindow->getHeight();
}

float NodeEditorWindow::getAspectRatio() const
{
	return (float)m_sdlWindow->getAspectRatio();
}

bool NodeEditorWindow::onSDLEvent(const SDL_Event* event)
{
	m_sdlWindow->onSDLEvent(event);

	return ImGui_ImplSDL2_ProcessEvent(event);
}

void NodeEditorWindow::configImGui()
{
	ImGuiIO& io = ImGui::GetIO();

	io.Fonts->AddFontFromFileTTF(
		getDefaultJapaneseFontPath().string().c_str(), 16, NULL, io.Fonts->GetGlyphRangesJapanese());
	//TODO: Find these fonts
	//io.Fonts->AddFontFromFileTTF(getDefaultKoreanFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesKorean();
	//io.Fonts->AddFontFromFileTTF(getDefaultChineseFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesChineseFull();
	//io.Fonts->AddFontFromFileTTF(getDefaultCyrillicFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesCyrillic();
	//io.Fonts->AddFontFromFileTTF(getDefaultThaiFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesThai();
	//io.Fonts->AddFontFromFileTTF(getDefaultVietnameseFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesVietnamese();

	// Setup Dear ImGui style
	ImGui::StyleColorsDark();

	static const ImWchar icons_ranges[] = {ICON_MIN_FK, ICON_MAX_FK, 0};
	ImFontConfig icons_config;
	icons_config.MergeMode = true;
	icons_config.PixelSnapH = true;
	
	m_NormalIconFont = io.Fonts->AddFontFromFileTTF(
		getForkAwesomeWebFontPath().string().c_str(),
		14, &icons_config, icons_ranges);

	icons_config.GlyphOffset.y += (22 - 17) * 0.5f;
	m_BigIconFont = io.Fonts->AddFontFromFileTTF(
		getForkAwesomeWebFontPath().string().c_str(),
		22, &icons_config, icons_ranges);
}

void NodeEditorWindow::configImNodes()
{
	ImNodes::GetIO().AltMouseButton = ImGuiMouseButton_Right;

	ImNodes::GetStyle().NodePadding = ImVec2(12.0f, 5.0f);
	ImNodes::GetStyle().PinOffset = -16.0f;
	ImNodes::GetStyle().PinCircleRadius = 5.0f;
	ImNodes::GetStyle().NodeCornerRounding = 6.0f;
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackground] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_GridBackground] = IM_COL32(38, 38, 38, 255);
	ImNodes::GetStyle().Colors[ImNodesCol_GridLine] = IM_COL32(53, 53, 53, 255);
}

void NodeEditorWindow::pushImGuiStyles()
{
	ImGui::PushFont(m_NormalIconFont);

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(6, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(8, 2));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 6));
	ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 12);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3);
	ImGui::PushStyleVar(ImGuiStyleVar_GrabRounding, 2);

	ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.94f, 0.94f, 0.94f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TextDisabled, ImVec4(0.66f, 0.66f, 0.66f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImVec4(0.4f, 0.4f, 0.4f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_TitleBg, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TitleBgActive, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TitleBgCollapsed, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_MenuBarBg, ImVec4(0.06f, 0.06f, 0.06f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ScrollbarBg, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Tab, ImVec4(0.06f, 0.06f, 0.06f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TabHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TabActive, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGrip, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGripHovered, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGripActive, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_SeparatorActive, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_DragDropTarget, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
}

void NodeEditorWindow::popImGuiStyles()
{
	ImGui::PopFont();
	ImGui::PopStyleVar(7);
	ImGui::PopStyleColor(26);
}