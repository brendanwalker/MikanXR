//-- includes -----
#include "NodeEditorWindow.h"
#include "Logger.h"

#include "GlCommon.h"
#include "GlBufferBlock.h"
#include "GlUniformBlock.h"
#include "GlFrameBuffer.h"
#include "GlProgram.h"
#include "GlStateStack.h"
#include "GlShaderCache.h"
#include "GlShaderVar.h"
#include "GlTexture.h"
#include "EditorNode.h"
#include "EditorNodeConstants.h"
#include "EditorNodeUtil.h"
#include "EditorPin.h"
#include "MathGLM.h"
#include "Graphs/NodeGraph.h"
#include "SdlManager.h"
#include "SdlWindow.h"
#include "TextStyle.h"

#include "imgui.h"
#include "misc/cpp/imgui_stdlib.h"
#include "backends/imgui_impl_sdl.h"
#include "backends/imgui_impl_opengl3.h"

#include "imnodes.h"
// Autogenerated header containing Unicode Icon IDs from "forkawesome-webfont.ttf"
#include "IconsForkAwesome.h"

#include "tinyfiledialogs.h" // Cross-platform file dialogs library

#include <easy/profiler.h>

//-- public methods -----
NodeEditorWindow::NodeEditorWindow()
	: m_sdlWindow(SdlWindowUniquePtr(new SdlWindow))
	, m_glStateStack(GlStateStackUniquePtr(new GlStateStack))
	, m_shaderCache(GlShaderCacheUniquePtr(new GlShaderCache))
{}

NodeEditorWindow::~NodeEditorWindow()
{
}

GlLineRenderer* NodeEditorWindow::getLineRenderer()
{
	return nullptr;
}

GlTextRenderer* NodeEditorWindow::getTextRenderer()
{
	return nullptr;
}

GlStateStack& NodeEditorWindow::getGlStateStack()
{
	return *m_glStateStack.get();
}

bool NodeEditorWindow::startup()
{
	EASY_FUNCTION();

	bool success = true;

	MIKAN_LOG_INFO("NodeEditorWindow::init()") << "Initializing NodeEditorWindow";

	static const int k_node_window_pixel_width = 1080;
	static const int k_node_window_pixel_height = 720;

	auto windowTitle = "Node Editor";
	m_sdlWindow
		->setTitle(windowTitle)
		->setSize(k_node_window_pixel_width, k_node_window_pixel_height);
	if (!m_sdlWindow->startup())
	{
		MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize main SDK window: ";
		success = false;
	}

	// Setup ImGui context
	if (success)
	{
		// Setup ImGui context
		IMGUI_CHECKVERSION();
		m_imguiContext = ImGui::CreateContext();
		if (m_imguiContext != NULL)
		{
			configImGui();
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to create imgui context";
			success = false;
		}
	}

	// Setup ImGui SDL backend
	if (success)
	{
		if (ImGui_ImplSDL2_InitForOpenGL(
			m_sdlWindow->getInternalSdlWindow(),
			m_sdlWindow->getInternalGlContext()))
		{
			m_imguiSDLBackendInitialised= true;
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize imgui SDL backend";
			success = false;
		}
	}

	// Setup ImGui OpenGL backend
	const std::string& glsl_version= SdlManager::getInstance()->getGlslVersion();
	if (success)
	{
		if (ImGui_ImplOpenGL3_Init(glsl_version.c_str()))
		{
			m_imguiOpenGLBackendInitialised= true;
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to initialize imgui openGL backend";
			success = false;
		}
	}

	// Setup the ImNodes context
	if (success)
	{
		m_imnodesContext = ImNodes::CreateContext();
		if (m_imnodesContext != nullptr)
		{
			configImNodes();
		}
		else
		{
			MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Unable to create imnodes context";
			success = false;
		}
	}

	if (success && !m_shaderCache->startup())
	{
		MIKAN_LOG_ERROR("NodeEditorWindow::startup") << "Failed to initialize shader cache!";
		success = false;
	}

	if (success)
	{
		static const glm::vec4 k_clear_color = glm::vec4(0.45f, 0.45f, 0.5f, 1.f);

		glClearColor(k_clear_color.r, k_clear_color.g, k_clear_color.b, k_clear_color.a);
		glViewport(0, 0, m_sdlWindow->getWidth(), m_sdlWindow->getHeight());

		// Set default state flags at the base of the stack
		m_glStateStack->pushState()
			.enableFlag(eGlStateFlagType::light0)
			.enableFlag(eGlStateFlagType::texture2d)
			.enableFlag(eGlStateFlagType::depthTest)
			.disableFlag(eGlStateFlagType::cullFace)
			// This has to be enabled since the point drawing shader will use gl_PointSize.
			.enableFlag(eGlStateFlagType::programPointSize);
	}

	if (success)
	{
		// TODO: Use node graph assigned to this window
		m_nodeGraph = std::make_shared<NodeGraph>();
	}

	return success;
}

void NodeEditorWindow::update()
{
	EASY_FUNCTION();

	// Update nodes
	bool needsUpdate = false;
	for (int i = 0; i < m_Programs.size(); i++)
	{
		if (!m_Programs[i]->isProgramCompiled() || m_OnInit)
		{
			m_Programs[i]->compileProgram();
			for (auto& node : m_Nodes)
			{
				if (node->type == EditorNodeType::PROGRAM)
				{
					EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(node);
					if (progNode->target == m_Programs[i])
					{
						UpdateProgramNode(node->id, i);
						needsUpdate = true;
					}
				}
			}
		}
	}
	for (int i = 0; i < m_Framebuffers.size(); i++)
	{
		if (m_Framebuffers[i]->needsInit())
		{
			m_Framebuffers[i]->createFrameBuffer();
			for (auto& node : m_Nodes)
			{
				if (node->type == EditorNodeType::PROGRAM)
				{
					EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(node);
					if (progNode->framebuffer == m_Framebuffers[i])
					{
						SetProgramNodeFramebuffer(progNode, i);
						needsUpdate = true;
					}
				}
			}
		}
	}
	if (needsUpdate)
	{
		UpdatePins();
		UpdateLinks();
	}

	if (m_OnInit)
	{
		for (auto texture : m_Textures)
		{
			texture->reloadTextureFromImagePath();
		}
	}

	if (!m_IsPlaying)
	{
		m_OnInit = false;
		return;
	}

	// Execute on init
	if (m_OnInit)
	{
		m_StartTime = std::chrono::high_resolution_clock::now();

		EditorProgramNodePtr progNode = 0;
		EditorEventNodePtr onInitNode = std::static_pointer_cast<EditorEventNode>(m_Nodes[0]);
		if (onInitNode->pinsOut[0]->connectedLinks.size() > 0)
		{
			progNode =
				std::static_pointer_cast<EditorProgramNode>(
					GetConnectedPin(onInitNode, onInitNode->pinsOut[0]->connectedLinks[0])->ownerNode);
		}
		while (progNode)
		{
			ExecuteProgramNode(progNode);

			if (progNode->flowOut->connectedLinks.size() > 0)
			{
				progNode = 
					std::static_pointer_cast<EditorProgramNode>(
						GetConnectedPin(progNode, progNode->flowOut->connectedLinks[0])->ownerNode);
			}
			else
			{
				progNode.reset();
			}
		}

		m_OnInit = false;
	}

	// Execute on frame
	EditorProgramNodePtr progNode = 0;
	EditorEventNodePtr onFrameNode = std::static_pointer_cast<EditorEventNode>(m_Nodes[1]);
	if (onFrameNode->pinsOut[0]->connectedLinks.size() > 0)
	{
		progNode = 
			std::static_pointer_cast<EditorProgramNode>(
				GetConnectedPin(onFrameNode, onFrameNode->pinsOut[0]->connectedLinks[0])->ownerNode);
	}
	while (progNode)
	{
		ExecuteProgramNode(progNode);

		if (progNode->flowOut->connectedLinks.size() > 0)
		{
			progNode = 
				std::static_pointer_cast<EditorProgramNode>(
					GetConnectedPin(progNode, progNode->flowOut->connectedLinks[0])->ownerNode);
		}
		else
		{
			progNode.reset();
		}
	}

	m_PingPongSwap = !m_PingPongSwap;
}

void NodeEditorWindow::render()
{
	EASY_FUNCTION();

	// Clear the window
	m_sdlWindow->renderBegin();

	// Tell ImGui to prepare for a new frame
	ImGui_ImplOpenGL3_NewFrame();
	ImGui_ImplSDL2_NewFrame();
	ImGui::NewFrame();

	// Draw the current state if the editor window
	m_isRenderingUI = true;
	renderUI();
	m_isRenderingUI = false;

	// Tell ImGui to render the UI draw commands to the GL context
	ImGui::Render();
	glViewport(0, 0, (int)getWidth(), (int)getHeight());
	ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

	// Call SDL_GL_SwapWindow
	m_sdlWindow->renderEnd();
}


void NodeEditorWindow::renderUI()
{
	pushImGuiStyles();

	ImGui::SetNextWindowSize(ImVec2(getWidth(), getHeight()), ImGuiCond_Once);
	ImGui::Begin("Node Editor");

		// Toolbar
		renderToolbar();

		// Left Panel
		renderLeftPanel();

		ImGui::SameLine();
		ImGui::BeginChild("Main Panel", ImVec2(ImGui::GetContentRegionAvail().x - 350,
											   ImGui::GetContentRegionAvail().y));
			// Main Frame
			renderMainFrame();

			// Bottom Panel
			renderBottomPanel();

		ImGui::EndChild();

		// Right Panel
		renderRightPanel();

	ImGui::End();

	popImGuiStyles();
}

void NodeEditorWindow::renderToolbar()
{
	ImGui::PushFont(m_BigIconFont);

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0);
	ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	ImGui::BeginChild("Toolbar", ImVec2(ImGui::GetContentRegionAvail().x, 40));

	ImGui::SetCursorPosY((ImGui::GetWindowHeight() - 30) * 0.5f);
	if (ImGui::Button(ICON_FK_FLOPPY_O "   Save", ImVec2(0, 30)))
	{
		// TODO Serializing the hole thing seems imposible...
	}

	// Editor Control
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 4.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 4));
		ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));

		ImGui::SameLine();
		ImGui::BeginChild("EditorControl", ImVec2(70, 30), true, ImGuiWindowFlags_NoScrollbar);
		ImGui::SetCursorPosY((ImGui::GetWindowHeight() - ImGui::GetTextLineHeight()) * 0.5f);

		if (m_IsPlaying)
		{
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.3f, 0.3f, 1.0f));
			if (ImGui::SmallButton(ICON_FK_STOP))
				m_IsPlaying = false;
		}
		else
		{
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 0.8f, 0.5f, 1.0f));
			if (ImGui::SmallButton(ICON_FK_PLAY))
			{
				m_OnInit = true;
				m_IsPlaying = true;
			}
		}
		ImGui::PopStyleColor();

		ImGui::SameLine();
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
		if (ImGui::SmallButton(ICON_FK_UNDO))
			m_OnInit = true;
		ImGui::PopStyleColor();

		ImGui::EndChild();
		ImGui::PopStyleColor(3);
		ImGui::PopStyleVar(2);
	}

	ImGui::EndChild();

	ImGui::PopStyleVar(3);
	ImGui::PopStyleColor(4);

	ImGui::PopFont();
}

void NodeEditorWindow::renderLeftPanel()
{
	ImGui::BeginChild("Left Panel", ImVec2(200, ImGui::GetContentRegionAvail().y));

	// Programs
	{
		// Add button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(180);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_program"))
		{
			ImNodes::ClearLinkSelection();
			ImNodes::ClearNodeSelection();

			std::string name = "Program " + std::to_string(m_Programs.size() + 1);
			AddProgram(m_shaderCache->allocateEmptyGlProgram(name));

			m_SelectedItemType = SelectedItemType::PROGRAM;
			m_SelectedItemId = (int)m_Programs.size() - 1;
		}
		ImGui::SameLine();
		ImGui::SetCursorPosX(xPos);

		// Title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("PROGRAMS", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::SameLine();
		ImGui::SetCursorPosX(180);
		ImGui::Text(ICON_FK_PLUS_CIRCLE);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			for (int i = 0; i < m_Programs.size(); i++)
			{
				// Item
				std::string name = "\t\t" + m_Programs[i]->getProgramCode().getProgramName();
				name += "##program" + std::to_string(i);
				bool isSelected = m_SelectedItemType == SelectedItemType::PROGRAM;
				isSelected = isSelected && (m_SelectedItemId == i);
				if (ImGui::Selectable(name.c_str(), &isSelected))
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					if (isSelected)
					{
						m_SelectedItemType = SelectedItemType::PROGRAM;
						m_SelectedItemId = i;
					}
					else
					{
						m_SelectedItemType = SelectedItemType::NONE;
						m_SelectedItemId = -1;
					}
				}
				if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
				{
					ImGui::SetDragDropPayload("program", &i, sizeof(int));
					ImGui::Text(m_Programs[i]->getProgramCode().getProgramName().c_str());
					ImGui::EndDragDropSource();
				}

				// Context menu
				ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
				ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
				ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
				ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
				if (ImGui::BeginPopupContextItem())
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					m_SelectedItemType = SelectedItemType::PROGRAM;
					m_SelectedItemId = i;

					if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						DeleteSelectedItem();

					ImGui::EndPopup();
				}
				ImGui::PopStyleColor(2);
				ImGui::PopStyleVar(3);
			}
			ImGui::PopStyleColor();
		}
	}

	// Framebuffers
	{
		// Add button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(180);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_framebuffer"))
		{
			ImNodes::ClearLinkSelection();
			ImNodes::ClearNodeSelection();

			std::string name = "Framebuffer " + std::to_string(m_Framebuffers.size());
			GlFrameBufferPtr framebuffer = std::make_shared<GlFrameBuffer>(name);
			AddFramebuffer(framebuffer);

			m_SelectedItemType = SelectedItemType::FRAMEBUFFER;
			m_SelectedItemId = (int)m_Framebuffers.size() - 1;
		}
		ImGui::SameLine();
		ImGui::SetCursorPosX(xPos);

		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("FRAMEBUFFERS", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::SameLine();
		ImGui::SetCursorPosX(180);
		ImGui::Text(ICON_FK_PLUS_CIRCLE);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			for (int i = 1; i < m_Framebuffers.size(); i++)
			{
				// Item
				std::string name = "\t\t" + m_Framebuffers[i]->getName();
				name += "##framebuffer" + std::to_string(i);
				bool isSelected = m_SelectedItemType == SelectedItemType::FRAMEBUFFER;
				isSelected = isSelected && (m_SelectedItemId == i);
				if (ImGui::Selectable(name.c_str(), &isSelected))
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					if (isSelected)
					{
						m_SelectedItemType = SelectedItemType::FRAMEBUFFER;
						m_SelectedItemId = i;
					}
					else
					{
						m_SelectedItemType = SelectedItemType::NONE;
						m_SelectedItemId = -1;
					}
				}

				if (i == 0)
					continue;
				// Context menu
				ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
				ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
				ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
				ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
				if (ImGui::BeginPopupContextItem())
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					m_SelectedItemType = SelectedItemType::FRAMEBUFFER;
					m_SelectedItemId = i;

					if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						DeleteSelectedItem();

					ImGui::EndPopup();
				}
				ImGui::PopStyleColor(2);
				ImGui::PopStyleVar(3);
			}
			ImGui::PopStyleColor();
		}
	}

	ImGui::EndChild();
}

void NodeEditorWindow::renderMainFrame()
{
	ImGui::BeginChild("Main", ImVec2(ImGui::GetContentRegionAvail().x,
									 ImGui::GetContentRegionAvail().y - 226));

	ImNodes::BeginNodeEditor();

	NodeEditorState editorState;
	editorState.bLinkHanged= m_bLinkHanged;
	editorState.hangPos= m_HangPos;
	editorState.startedLinkPinId= m_StartedLinkPinId;

	m_nodeGraph->editorRender(&editorState);

	// Nodes rendering
	for (auto& node : m_Nodes)
	{
		if (ImNodes::IsNodeSelected(node->id))
		{
			ImNodes::PushStyleVar(ImNodesStyleVar_NodeBorderThickness, 2.6f);
			ImNodes::PushColorStyle(ImNodesCol_NodeOutline, IM_COL32(220, 140, 0, 255));
		}
		else
		{
			ImNodes::PushStyleVar(ImNodesStyleVar_NodeBorderThickness, 2.0f);
			ImNodes::PushColorStyle(ImNodesCol_NodeOutline, IM_COL32(24, 24, 24, 255));
		}
		// Event nodes
		if (node->type == EditorNodeType::EVENT)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(150, 30, 30, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(150, 30, 30, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(150, 30, 30, 225));

			EditorEventNodePtr eventNode = std::static_pointer_cast<EditorEventNode>(node);
			ImNodes::BeginNode(eventNode->id);
			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			if (eventNode->eventNodeType == EditorEventNodeType::INIT)
				ImGui::Text("On Init");
			else
				ImGui::Text("On Frame");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			for (auto& pin : eventNode->pinsOut)
			{
				float alpha = 1.0f;
				if (m_StartedLinkPinId == -1)
					alpha = 1.0f;
				else
				{
					if (m_StartedLinkPinId == pin->id ||
						(m_Pins[m_StartedLinkPinId]->type == pin->type
						 && m_Pins[m_StartedLinkPinId]->size == pin->size
						 && !m_Pins[m_StartedLinkPinId]->isOutput
						 && m_Pins[m_StartedLinkPinId]->ownerNode != node))
						alpha = 1.0f;
					else
						alpha = 0.2f;
				}
				ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, alpha));

				ImNodesPinShape pinShape = BeginPin(pin, alpha);

				ImNodes::BeginOutputAttribute(pin->id, pinShape);
				ImGui::Text(" ");
				ImGui::SameLine();
				ImGui::Dummy(ImVec2(11.0f, 1.0f));
				ImNodes::EndOutputAttribute();

				EndPin();

				ImGui::PopStyleColor();
			}
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Program nodes
		if (node->type == EditorNodeType::PROGRAM)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(85, 85, 85, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(85, 85, 85, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(85, 85, 85, 225));

			EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(node);
			ImNodes::BeginNode(progNode->id);
			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::Text(progNode->target->getProgramCode().getProgramName().c_str());
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			// Compute node width
			float nodeWidth = ImGui::CalcTextSize(progNode->target->getProgramCode().getProgramName().c_str()).x;
			float nodeInWidth = 0.0f;
			float nodeOutWidth = 0.0f;
			for (auto& pin : progNode->pinsIn)
			{
				float textWidth = ImGui::CalcTextSize(pin->name.c_str()).x + 11.0f;
				float inputWidth = 11.0f;
				if (pin->connectedLinks.size() == 0)
				{
					if (pin->type == EditorPinType::FLOAT || pin->type == EditorPinType::INT)
						inputWidth = 50 + textWidth;
					else if (pin->type == EditorPinType::FLOAT2 || pin->type == EditorPinType::INT2)
						inputWidth = 100 + 11.0f;
					else if (pin->type == EditorPinType::FLOAT3 || pin->type == EditorPinType::INT3)
						inputWidth = 150 + 11.0f;
					else if (pin->type == EditorPinType::FLOAT4 || pin->type == EditorPinType::INT4)
						inputWidth = 200 + 11.0f;
				}
				nodeInWidth = std::max(nodeInWidth, std::max(textWidth, inputWidth));
			}
			for (auto& pin : progNode->pinsOut)
				nodeOutWidth = std::max(nodeOutWidth, ImGui::CalcTextSize(pin->name.c_str()).x + 11.0f);
			nodeWidth = std::max(nodeWidth, nodeInWidth + nodeOutWidth);

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			// Inputs
			ImGui::BeginGroup();
			for (auto& pin : progNode->pinsIn)
				InputPin(node, pin);
			ImGui::EndGroup();
			ImGui::SameLine();
			// Outputs
			ImGui::BeginGroup();
			for (auto& pin : progNode->pinsOut)
			{
				float alpha = 0.2f;
				if (m_StartedLinkPinId == -1)
					alpha = 1.0f;
				else
				{
					if (m_StartedLinkPinId == pin->id ||
						(m_Pins[m_StartedLinkPinId]->type == pin->type
						 && !m_Pins[m_StartedLinkPinId]->isOutput
						 && m_Pins[m_StartedLinkPinId]->ownerNode != node))
					{
						if (m_Pins[m_StartedLinkPinId]->size == pin->size)
							alpha = 1.0f;
						else if ((m_Pins[m_StartedLinkPinId]->ownerNode->type == EditorNodeType::PINGPONG
								  && m_Pins[m_StartedLinkPinId]->size == 0) ||
								 (node->type == EditorNodeType::PINGPONG && pin->size == 0))
							alpha = 1.0f;
					}
				}
				ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, alpha));

				ImNodesPinShape pinShape = BeginPin(pin, alpha);

				ImNodes::BeginOutputAttribute(pin->id, pinShape);
				float width = nodeWidth - nodeInWidth - ImGui::CalcTextSize(pin->name.c_str()).x;
				ImGui::Dummy(ImVec2(width, 1.0f));
				ImGui::SameLine();
				ImGui::Text(pin->name.c_str());
				ImGui::SameLine();
				ImGui::Dummy(ImVec2(11.0f, 1.0f));
				ImNodes::EndOutputAttribute();

				EndPin();

				ImGui::PopStyleColor();
			}
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Block nodes
		if (node->type == EditorNodeType::BLOCK)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(83, 124, 153, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(83, 124, 153, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(83, 124, 153, 225));

			EditorBlockNodePtr blockNode = std::static_pointer_cast<EditorBlockNode>(node);
			ImNodes::BeginNode(blockNode->id);
			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::Text("Block");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			// Inputs
			ImGui::BeginGroup();
			for (auto& pin : blockNode->pinsIn)
				InputPin(node, pin);
			ImGui::EndGroup();
			ImGui::SameLine();
			// Outputs
			ImGui::BeginGroup();
			for (auto& pin : blockNode->pinsOut)
				OutputPin(node, pin);
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Texture nodes
		if (node->type == EditorNodeType::TEXTURE)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(150, 130, 110, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(150, 130, 110, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(150, 130, 110, 225));

			EditorTextureNodePtr texNode = std::static_pointer_cast<EditorTextureNode>(node);
			ImNodes::BeginNode(texNode->id);

			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::Text("Texture");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			ImGui::Image((void*)(intptr_t)texNode->target->getGlTextureId(), ImVec2(100, 100));

			ImGui::SameLine();
			ImGui::BeginGroup();
			for (auto& pin : texNode->pinsOut)
				OutputPin(node, pin);
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Image nodes
		if (node->type == EditorNodeType::IMAGE)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(118, 32, 140, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(118, 32, 140, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(118, 32, 140, 225));

			EditorImageNodePtr imgNode = std::static_pointer_cast<EditorImageNode>(node);
			ImNodes::BeginNode(imgNode->id);

			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::Text("Image");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			// Inputs
			ImGui::BeginGroup();
			for (auto& pin : imgNode->pinsIn)
				InputPin(node, pin);
			ImGui::EndGroup();
			ImGui::SameLine();
			// Outputs
			ImGui::BeginGroup();
			for (auto& pin : imgNode->pinsOut)
				OutputPin(node, pin);
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Ping-pong nodes
		if (node->type == EditorNodeType::PINGPONG)
		{
			ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(83, 124, 153, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(83, 124, 153, 225));
			ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(83, 124, 153, 225));

			EditorPingPongNodePtr pingpongNode = std::static_pointer_cast<EditorPingPongNode>(node);
			ImNodes::BeginNode(pingpongNode->id);

			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			ImGui::Text("Ping-Pong");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			// Inputs
			ImGui::BeginGroup();
			for (auto& pin : pingpongNode->pinsIn)
				InputPin(node, pin);
			ImGui::EndGroup();
			ImGui::SameLine();
			// Outputs
			ImGui::BeginGroup();
			for (auto& pin : pingpongNode->pinsOut)
				OutputPin(node, pin);
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}
		// Other nodes
		else if (node->type == EditorNodeType::TIME || node->type == EditorNodeType::MOUSE_POS)
		{
			if (node->type == EditorNodeType::TIME)
			{
				ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(110, 146, 104, 225));
				ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(110, 146, 104, 225));
				ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(110, 146, 104, 225));
			}
			else
			{
				ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(160, 160, 40, 225));
				ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(160, 160, 40, 225));
				ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(160, 160, 40, 225));
			}

			ImNodes::BeginNode(node->id);

			// Title
			ImNodes::BeginNodeTitleBar();
			ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
			if (node->type == EditorNodeType::TIME)
				ImGui::Text("Time");
			else if (node->type == EditorNodeType::MOUSE_POS)
				ImGui::Text("Mouse Position");
			ImGui::PopStyleVar();
			ImNodes::EndNodeTitleBar();

			ImGui::Dummy(ImVec2(1.0f, 0.5f));
			// Outputs
			ImGui::BeginGroup();
			for (auto& pin : node->pinsOut)
				OutputPin(node, pin);
			ImGui::EndGroup();
			ImGui::Dummy(ImVec2(1.0f, 0.5f));

			ImNodes::EndNode();

			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
			ImNodes::PopColorStyle();
		}

		const ImVec2 nodePos = ImNodes::GetNodeScreenSpacePos(node->id);
		node->nodePos = {nodePos.x, nodePos.y};

		ImNodes::PopColorStyle();
		ImNodes::PopStyleVar();
	}

	// Links Rendering
	for (auto& link : m_Links)
	{
		int alpha = m_StartedLinkPinId == -1 ? 255 : 50;
		if (link->pPin1->type == EditorPinType::FLOW)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(225, 225, 225, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 255, 255, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 255, 255, 255));
		}
		else if (link->pPin1->type == EditorPinType::INT)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(33, 227, 175, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(135, 239, 195, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(135, 239, 195, 255));
		}
		else if (link->pPin1->type == EditorPinType::FLOAT)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(156, 253, 65, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(144, 225, 137, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(144, 225, 137, 255));
		}
		else if (link->pPin1->type == EditorPinType::BLOCK)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(6, 165, 239, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(137, 196, 247, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(137, 196, 247, 255));
		}
		else if (link->pPin1->type == EditorPinType::TEXTURE)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(148, 0, 0, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(183, 137, 137, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(183, 137, 137, 255));
		}
		else if (link->pPin1->type == EditorPinType::IMAGE)
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(200, 130, 255, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(220, 170, 255, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(220, 170, 255, 255));
		}
		else
		{
			ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(252, 200, 35, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 217, 140, alpha));
			ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 217, 140, 255));
		}
		ImNodes::Link(link->id, link->pPin1->id, link->pPin2->id);
		ImNodes::PopColorStyle();
		ImNodes::PopColorStyle();
		ImNodes::PopColorStyle();
	}

	ImNodes::EndNodeEditor();
	ImGui::EndChild();

	// Node selection
	if (ImNodes::NumSelectedNodes() == 1 && ImNodes::NumSelectedLinks() == 0)
	{
		int* ids = new int;
		ImNodes::GetSelectedNodes(ids);
		int id = *ids;
		delete ids;
		if (m_Nodes[id]->type == EditorNodeType::PROGRAM)
			m_SelectedItemType = SelectedItemType::PROGRAM_NODE;
		else if (m_Nodes[id]->type == EditorNodeType::BLOCK)
			m_SelectedItemType = SelectedItemType::BUFFER_NODE;
		else if (m_Nodes[id]->type == EditorNodeType::IMAGE)
			m_SelectedItemType = SelectedItemType::IMAGE_NODE;
		else if (m_Nodes[id]->type == EditorNodeType::PINGPONG)
			m_SelectedItemType = SelectedItemType::PINGPONG_NODE;
		else
			m_SelectedItemType = SelectedItemType::NODE;
		m_SelectedItemId = id;
	}
	else if (ImNodes::NumSelectedNodes() > 1 || ImNodes::NumSelectedLinks() > 0)
		m_SelectedItemType = SelectedItemType::NODES;
	else if (m_SelectedItemType >= SelectedItemType::NODES)
		m_SelectedItemType = SelectedItemType::NONE;

	// Start link
	if (ImNodes::IsLinkStarted(&m_StartedLinkPinId))
	{
		if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::FLOW)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(225, 225, 225, 255);
		else if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::INT)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(33, 227, 175, 255);
		else if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::FLOAT)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(156, 253, 65, 255);
		else if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::BLOCK)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(6, 165, 239, 255);
		else if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::TEXTURE)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(148, 0, 0, 255);
		else if (m_Pins[m_StartedLinkPinId]->type == EditorPinType::IMAGE)
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(200, 130, 255, 255);
		else
			ImNodes::GetStyle().Colors[ImNodesCol_Link] = IM_COL32(252, 200, 35, 255);
	}
	// Drop link
	if (ImNodes::IsLinkDropped())
	{
		ImGui::OpenPopup("editor_context_menu_nodes");
		m_bLinkHanged = true;

		m_HangPos = ImGui::GetMousePos();
	}

	// Link creation
	int startPinId, endPinId;
	if (ImNodes::IsLinkCreated(&startPinId, &endPinId))
	{
		m_StartedLinkPinId = -1;
		CreateLink(startPinId, endPinId);
	}

	// Context menu
	if (ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).x == 0.0f
		&& ImGui::GetMouseDragDelta(ImGuiMouseButton_Right).y == 0.0f
		&& ImGui::IsMouseReleased(ImGuiMouseButton_Right)
		&& ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows))
	{
		int id = -1;
		if (ImNodes::IsNodeHovered(&id))
		{
			ImNodes::ClearNodeSelection();
			ImNodes::ClearLinkSelection();
			ImNodes::SelectNode(id);
			m_SelectedItemType = SelectedItemType::NODE;
			m_SelectedItemId = id;
			ImGui::OpenPopup("editor_context_menu_node");
		}
		else if (ImNodes::IsLinkHovered(&id))
		{
			ImNodes::ClearNodeSelection();
			ImNodes::ClearLinkSelection();
			ImNodes::SelectLink(id);
			m_SelectedItemType = SelectedItemType::LINK;
			m_SelectedItemId = id;
			ImGui::OpenPopup("editor_context_menu_link");
		}
		else
		{
			ImGui::OpenPopup("editor_context_menu_nodes");
			m_HangPos = ImGui::GetMousePos();
		}
	}
	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	if (ImGui::BeginPopup("editor_context_menu_node"))
	{
		if (m_Nodes[m_SelectedItemId]->type != EditorNodeType::EVENT)
		{
			if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
			{
				DeleteNode(m_SelectedItemId);
				UpdateNodes();
				UpdatePins();
				UpdateLinks();
			}
		}
		else
			ImGui::CloseCurrentPopup();
		ImGui::EndPopup();
	}
	else if (ImGui::BeginPopup("editor_context_menu_link"))
	{
		if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
		{
			DeleteLink(m_SelectedItemId);
			UpdateLinks();
		}
		ImGui::EndPopup();
	}
	else if (ImGui::BeginPopup("editor_context_menu_nodes"))
	{
		if (m_StartedLinkPinId != -1)
		{
			EditorPinPtr pin = m_Pins[m_StartedLinkPinId];
			if (pin->type == EditorPinType::BLOCK &&
				pin->ownerNode->type == EditorNodeType::PROGRAM)
			{
				if (!pin->isOutput)
				{
					if (ImGui::MenuItem("Block"))
						CreateBlockNode(m_HangPos, m_StartedLinkPinId);
					if (ImGui::MenuItem("Ping-Pong"))
					{
						CreatePingPongNode(m_HangPos);
						CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
					}
				}
				else
				{
					if (ImGui::MenuItem("Ping-Pong"))
					{
						CreatePingPongNode(m_HangPos);
						CreateLink(m_Nodes.back()->pinsIn[0]->id, pin->id);
					}
				}
			}
			else if (pin->type == EditorPinType::BLOCK &&
					 pin->ownerNode->type == EditorNodeType::PINGPONG)
			{
				if (ImGui::MenuItem("Ping-Pong"))
				{
					CreatePingPongNode(m_HangPos);
					if (!pin->isOutput)
						CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
					else
						CreateLink(m_Nodes.back()->pinsIn[0]->id, pin->id);
				}
			}
			else if (pin->type == EditorPinType::FLOW && m_Programs.size() > 0)
			{
				for (int i = 0; i < m_Programs.size(); i++)
				{
					if (ImGui::MenuItem(m_Programs[i]->getProgramCode().getProgramName().c_str()))
					{
						CreateProgramNode(i, m_HangPos);
						EditorProgramNodePtr newNode = 
							std::static_pointer_cast<EditorProgramNode>(m_Nodes.back());

						if (pin->isOutput)
							CreateLink(pin->id, newNode->flowIn->id);
						else
							CreateLink(newNode->flowOut->id, pin->id);
					}
				}
			}
			else if (pin->type == EditorPinType::TEXTURE &&
					 !pin->isOutput &&
					 m_Textures.size() > 0)
			{
				for (int i = 0; i < m_Textures.size(); i++)
				{
					std::string name = "Texture: " + m_Textures[i]->getName();
					if (ImGui::MenuItem(name.c_str()))
					{
						CreateTextureNode(i, m_HangPos);
						CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
					}
				}
			}
			else if (pin->type == EditorPinType::TEXTURE &&
					 pin->isOutput &&
					 pin->ownerNode->type == EditorNodeType::TEXTURE)
			{
				if (ImGui::MenuItem("Image"))
				{
					CreateImageNode(m_HangPos);
					CreateLink(m_Nodes.back()->pinsIn[0]->id, pin->id);
				}
			}
			else if (pin->type == EditorPinType::IMAGE &&
					 pin->ownerNode->type == EditorNodeType::PROGRAM &&
					 !pin->isOutput)
			{
				if (ImGui::MenuItem("Image"))
				{
					CreateImageNode(m_HangPos);
					CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
				}
				if (ImGui::MenuItem("Ping-Pong"))
				{
					CreatePingPongNode(m_HangPos, EditorPingPongNodeType::IMAGE);
					CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
				}
			}
			else if (pin->type == EditorPinType::IMAGE &&
					 pin->ownerNode->type == EditorNodeType::PINGPONG)
			{
				if (!pin->isOutput)
				{
					if (ImGui::MenuItem("Image"))
					{
						CreateImageNode(m_HangPos);
						CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
					}
				}
				if (ImGui::MenuItem("Ping-Pong"))
				{
					CreatePingPongNode(m_HangPos, EditorPingPongNodeType::IMAGE);
					if (!pin->isOutput)
						CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
					else
						CreateLink(m_Nodes.back()->pinsIn[0]->id, pin->id);
				}
			}
			else if (pin->type == EditorPinType::FLOAT && !pin->isOutput)
			{
				if (ImGui::MenuItem("Time"))
				{
					CreateTimeNode(m_HangPos);
					CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
				}
			}
			else if (pin->type == EditorPinType::FLOAT2 && !pin->isOutput)
			{
				if (ImGui::MenuItem("Mouse Position"))
				{
					CreateMousePosNode(m_HangPos);
					CreateLink(m_Nodes.back()->pinsOut[0]->id, pin->id);
				}
			}
			else
				ImGui::CloseCurrentPopup();
		}
		else
		{
			if (m_Programs.size() > 0)
			{
				for (int i = 0; i < m_Programs.size(); i++)
				{
					if (ImGui::MenuItem(m_Programs[i]->getProgramCode().getProgramName().c_str()))
						CreateProgramNode(i, m_HangPos);
				}
				ImGui::Separator();
			}
			if (m_Textures.size() > 0)
			{
				for (int i = 0; i < m_Textures.size(); i++)
				{
					std::string name = "Texture: " + m_Textures[i]->getName();
					if (ImGui::MenuItem(name.c_str()))
						CreateTextureNode(i, m_HangPos);
				}
				ImGui::Separator();
			}
			if (ImGui::MenuItem("Block"))
				CreateBlockNode(m_HangPos);
			if (ImGui::MenuItem("Image"))
				CreateImageNode(m_HangPos);
			if (ImGui::MenuItem("Ping-Pong"))
				CreatePingPongNode(m_HangPos);
			ImGui::Separator();
			if (ImGui::MenuItem("Time"))
				CreateTimeNode(m_HangPos);
			if (ImGui::MenuItem("Mouse Position"))
				CreateMousePosNode(m_HangPos);
		}
		ImGui::EndPopup();
	}
	else if (m_bLinkHanged)
	{
		m_bLinkHanged = false;
		m_StartedLinkPinId = -1;
	}
	ImGui::PopStyleColor(2);
	ImGui::PopStyleVar(3);

	// Drag and drop creation
	if (ImGui::BeginDragDropTarget())
	{
		if (auto payload = ImGui::AcceptDragDropPayload("program"))
		{
			IM_ASSERT(payload->DataSize == sizeof(int));
			int id = *(const int*)payload->Data;
			auto mousePos = ImGui::GetMousePos();
			CreateProgramNode(id, mousePos);
		}
		else if (auto payload = ImGui::AcceptDragDropPayload("texture"))
		{
			IM_ASSERT(payload->DataSize == sizeof(int));
			int id = *(const int*)payload->Data;
			auto mousePos = ImGui::GetMousePos();
			CreateTextureNode(id, mousePos);
		}
		ImGui::EndDragDropTarget();
	}

	// Delete key event
	if (ImGui::IsKeyPressed(ImGuiKey_Delete, false))
		DeleteSelectedItem();
}

void NodeEditorWindow::renderBottomPanel()
{
	ImGui::BeginChild("Bottom Panel", ImVec2(ImGui::GetContentRegionAvail().x, 216));
	if (ImGui::BeginTabBar("BottomTabBar"))
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
		if (ImGui::BeginTabItem("Textures"))
		{
			ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
			ImGui::BeginChild("TexturesSubFrame");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 6, ImGui::GetCursorPos().y + 6));
			if (ImGui::ImageButton("  Add##tex", ICON_FK_PLUS, ImVec2(70, 25), ImVec2(0.4f, 0.8f), ImVec2(0.4f, 1.0f)))
			{
				const char* filterItems[5] = {"*.jpg", "*.jpeg", "*.png", "*.bmp", "*.tga"};
				const char* filterDesc = "Image Files (*.jpg;*.jpeg;*.png;*.bmp;*.tga)";
				auto paths_c = tinyfd_openFileDialog("Load Texture", "", 5, filterItems, filterDesc, 1);
				if (paths_c)
				{
					std::stringstream ssPaths(paths_c);
					std::string path;
					while (std::getline(ssPaths, path, '|'))
					{
						std::string universalPath(path);
						std::replace(universalPath.begin(), universalPath.end(), '\\', '/');

						GlTexturePtr tex = std::make_shared<GlTexture>();
						tex->setImagePath(universalPath);

						if (tex->reloadTextureFromImagePath())
						{
							m_Textures.push_back(tex);
						}
					}
				}
			}

			ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 6);
			ImGui::Separator();

			// Textures browser
			{
				ImGui::BeginChild("TextureBrowser");

				ImGui::Dummy(ImVec2(1, 10));
				for (int i = 0; i < m_Textures.size(); i++)
				{
					ImGui::Dummy(ImVec2(10, 140));
					ImGui::SameLine();
					ImGui::BeginGroup();
					std::string idStr = "##texture" + std::to_string(i);
					ImGui::Button(idStr.c_str(), ImVec2(120, 140));

					if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
					{
						ImGui::SetDragDropPayload("texture", &i, sizeof(int));
						ImGui::Text(m_Textures[i]->getName().c_str());
						ImGui::EndDragDropSource();
					}

					// Context menu
					bool itemDeleted = false;
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
					ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
					ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
					ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
					if (ImGui::BeginPopupContextItem())
					{
						ImNodes::ClearLinkSelection();
						ImNodes::ClearNodeSelection();
						m_SelectedItemType = SelectedItemType::TEXTURE;
						m_SelectedItemId = i;

						if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						{
							DeleteSelectedItem();
							itemDeleted = true;
						}

						ImGui::EndPopup();
					}
					ImGui::PopStyleColor(2);
					ImGui::PopStyleVar(3);

					if (!itemDeleted)
					{
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10);
						ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 130);
						ImGui::Image((void*)(intptr_t)m_Textures[i]->getGlTextureId(), ImVec2(100, 100));
						ImGui::Dummy(ImVec2(2, 1));
						ImGui::SameLine();
						ImGui::SetNextItemWidth(108);
						ImGui::Text(m_Textures[i]->getName().c_str());
					}
					ImGui::EndGroup();

					ImGui::SameLine();
					if (ImGui::GetContentRegionAvail().x < 130)
					{
						ImGui::NewLine();
						ImGui::NewLine();
					}
				}
				ImGui::NewLine();
				ImGui::Dummy(ImVec2(1, 10));

				ImGui::EndChild();
			}

			ImGui::EndChild();
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			ImGui::EndTabItem();
		}
		ImGui::PopStyleVar();
		ImGui::EndTabBar();
	}
	ImGui::EndChild();
}

void NodeEditorWindow::renderRightPanel()
{
	ImGui::SameLine();
	ImGui::BeginChild("Right Panel", ImVec2(344, ImGui::GetContentRegionAvail().y));

	if (m_SelectedItemType == SelectedItemType::PROGRAM)
	{
		// Section 1: Basic info
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Program", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			// Name
			ImGui::Text("\t\tName");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			GlProgramCode& programCode= m_Programs[m_SelectedItemId]->getProgramCodeMutable();
			std::string name = programCode.getProgramName();
			if (ImGui::InputText("##progName", &name))
				programCode.setProgramName(name);
		}

		// Section 2: Shaders
		// Add Button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(325);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_shader"))
		{
		#if 0
			auto paths_c = tinyfd_openFileDialog("Add Shader", "", 0, 0, 0, 1);
			if (paths_c)
			{
				std::stringstream ssPaths(paths_c);
				std::string path;
				while (std::getline(ssPaths, path, '|'))
					m_Programs[m_SelectedItemId]->AddShader(
						PathUtils::makeUniversalPathString(path).c_str(),
						GL_VERTEX_SHADER);
			}
		#endif
		}
		ImGui::SameLine();
		ImGui::SetCursorPosX(xPos);

		// Title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		isNodeOpened = ImGui::CollapsingHeader("Shaders", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::SameLine();
		ImGui::SetCursorPosX(325);
		ImGui::Text(ICON_FK_PLUS_CIRCLE);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			const GlProgramCode& shaderCode= m_Programs[m_SelectedItemId]->getProgramCode();

			if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_shader"))
			{
			#if 0
				auto paths_c = tinyfd_openFileDialog("Add Shader", "", 0, 0, 0, 1);
				if (paths_c)
				{
					std::stringstream ssPaths(paths_c);
					std::string path;
					while (std::getline(ssPaths, path, '|'))
						m_Programs[m_SelectedItemId]->AddShader(
							PathUtils::makeUniversalPathString(path).c_str(),
							GL_VERTEX_SHADER);
				}
			#endif
			}
			std::vector<std::filesystem::path> shaders = 
				{
						shaderCode.getVertexShaderFilePath(), 
						shaderCode.getFragmeShaderFilePath()
				};
			for (int i = 0; i < shaders.size(); i++)
			{
				// Name
				std::string name = shaders[i].string();
				name = "\t" + name.substr(name.find_last_of('/') + 1);
				ImGui::SetNextItemWidth(150);
				ImGui::Text(name.c_str());

				#if 0
				// Type
				int iVar = 0;
				GLenum type = m_Programs[m_SelectedItemId]->GetShaderTypes()[i];
				if (type == GL_VERTEX_SHADER)
					iVar = 0;
				else if (type == GL_FRAGMENT_SHADER)
					iVar = 1;
				else if (type == GL_COMPUTE_SHADER)
					iVar = 2;
				const char* items = "Vertex\0Fragment\0Compute\0";
				std::string idStr = "##shadertype" + std::to_string(i);
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
				if (ImGui::Combo(idStr.c_str(), &iVar, items))
				{
					if (iVar == 0)
						m_Programs[m_SelectedItemId]->SetShaderType(i, GL_VERTEX_SHADER);
					else if (iVar == 1)
						m_Programs[m_SelectedItemId]->SetShaderType(i, GL_FRAGMENT_SHADER);
					else if (iVar == 2)
						m_Programs[m_SelectedItemId]->SetShaderType(i, GL_COMPUTE_SHADER);
				}
				ImGui::PopStyleColor();

				// Delete button
				ImGui::SameLine();
				ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
				ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
				idStr = ICON_FK_TRASH "##shader" + std::to_string(i);
				bool itemDeleted = false;
				if (ImGui::SmallButton(idStr.c_str()))
				{
					m_Programs[m_SelectedItemId]->RemoveShader(i);
					itemDeleted = true;
				}
				ImGui::PopStyleColor(3);
				ImGui::PopStyleVar();
				if (itemDeleted)
					break;
				#endif
			}
			ImGui::PopStyleColor();
		}
	}

	else if (m_SelectedItemType == SelectedItemType::FRAMEBUFFER)
	{
		if (m_SelectedItemId != 0)
		{
			ImGui::SetNextItemOpen(true, ImGuiCond_Once);
			ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
			ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
			ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
			ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
			ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
			bool isNodeOpened = ImGui::CollapsingHeader("Framebuffer", ImGuiTreeNodeFlags_SpanAvailWidth);
			ImGui::PopStyleVar(3);
			ImGui::PopStyleColor(3);

			if (isNodeOpened)
			{
				// Name
				ImGui::Text("\t\tName");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				std::string name = m_Framebuffers[m_SelectedItemId]->getName();
				if (ImGui::InputText("##framebufferName", &name))
					m_Framebuffers[m_SelectedItemId]->setName(name);

				// Size
				int x, y;
				m_Framebuffers[m_SelectedItemId]->getSize(&x, &y);
				ImGui::Text("\t\tWidth");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				if (ImGui::DragInt("##framebufferSizeX", &x, 1.0f, 0, 4096))
				{
					if (x < 0) x = 0;
					if (x > 4096) x = 4096;
					m_Framebuffers[m_SelectedItemId]->setSize(x, y);
				}
				ImGui::Text("\t\tHeight");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				if (ImGui::DragInt("##framebufferSizeY", &y, 1.0f, 0, 4096))
				{
					if (y < 0) y = 0;
					if (y > 4096) y = 4096;
					m_Framebuffers[m_SelectedItemId]->setSize(x, y);
				}

				// Attachments
				ImGui::Text("\t\tAttachments");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				int iVal = m_Framebuffers[m_SelectedItemId]->getNumAttachments();
				if (ImGui::SliderInt("##framebufferAttachments", &iVal, 0, 8))
				{
					if (iVal < 0) iVal = 0;
					if (iVal > 8) iVal = 8;
					m_Framebuffers[m_SelectedItemId]->setNumAttachments(iVal);
				}

				// Renderbuffer
				ImGui::Text("\t\tRenderbuffer");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				bool hasRenderbuffer = m_Framebuffers[m_SelectedItemId]->hasRenderbuffer();
				if (ImGui::Checkbox("##framebufferRenderbuffer", &hasRenderbuffer))
					m_Framebuffers[m_SelectedItemId]->setRenderbuffer(hasRenderbuffer);
			}
		}
	}

	else if (m_SelectedItemType == SelectedItemType::PROGRAM_NODE)
	{
		// title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Program Node", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			EditorProgramNodePtr node = std::static_pointer_cast<EditorProgramNode>(m_Nodes[m_SelectedItemId]);

			// Dispatch type
			ImGui::Text("\t\tDispatch Type");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			int iVal = (int)node->dispatchType;
			const char* items = "Array\0Compute\0";
			ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
			if (ImGui::Combo("##progNodeDispatchType", &iVal, items))
			{
				node->drawMode = GL_POINTS;
				if (iVal == 0)
				{
					node->dispatchType = EditorProgramDispatchType::ARRAY;
					node->dispatchSize[0] = 0;
					node->dispatchSize[1] = 0;
					node->dispatchSize[2] = 0;
				}
				else if (iVal == 1)
				{
					node->dispatchType = EditorProgramDispatchType::COMPUTE;
					node->dispatchSize[0] = 1;
					node->dispatchSize[1] = 1;
					node->dispatchSize[2] = 1;
					SetProgramNodeFramebuffer(node, 0);
				}
			}
			ImGui::PopStyleColor();

			if (node->dispatchType == EditorProgramDispatchType::ARRAY)
			{
				// Framebuffer
				ImGui::Text("\t\tFramebuffer");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));

				const std::string& frameBufferName= node->framebuffer ? node->framebuffer->getName() : "<INVALID>";
				if (ImGui::BeginCombo("##progNodeFramebuffer", frameBufferName.c_str()))
				{
					int index = 0;
					for (auto& framebuffer : m_Framebuffers)
					{
						const bool is_selected = (node->framebuffer == framebuffer);
						if (ImGui::Selectable(framebuffer->getName().c_str(), is_selected))
							SetProgramNodeFramebuffer(node, index);
						if (is_selected)
							ImGui::SetItemDefaultFocus();
						index++;
					}
					ImGui::EndCombo();
				}
				ImGui::PopStyleColor();

				// Draw mode
				ImGui::Text("\t\tDraw Mode");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				iVal = EditorNodeUtil::GLDrawModeToIndex(node->drawMode);
				items =
					"Points\0"
					"Line Strip\0"
					"Line Loop\0"
					"Lines\0"
					"Line Strip Adjacency\0"
					"Lines Adjacency\0"
					"Triangle Strip\0"
					"Triangle Fan\0"
					"Triangles\0"
					"Triangle Strip Adjacency\0"
					"Triangles Adjacency\0";
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
				if (ImGui::Combo("##progNodeDrawMode", &iVal, items))
					node->drawMode = EditorNodeUtil::IndexToGLDrawMode(iVal);
				ImGui::PopStyleColor();

				// Size
				ImGui::Text("\t\tSize");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				iVal = node->dispatchSize[0];
				if (ImGui::DragInt("##progNodeDrawSize", &iVal, 1.0f))
				{
					if (iVal < 0) iVal = 0;
					node->dispatchSize[0] = iVal;
				}
			}

			else if (node->dispatchType == EditorProgramDispatchType::COMPUTE)
			{
				int size[3]{};
				size[0] = node->dispatchSize[0];
				size[1] = node->dispatchSize[1];
				size[2] = node->dispatchSize[2];
				// Dispatch size
				ImGui::Text("\t\tWork Group Size X");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				if (ImGui::DragInt("##progNodeWorkGroupSizeX", &size[0], 1.0f))
				{
					if (size[0] < 0) size[0] = 0;
					node->dispatchSize[0] = size[0];
				}
				ImGui::Text("\t\tWork Group Size Y");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				if (ImGui::DragInt("##progNodeWorkGroupSizeY", &size[1], 1.0f))
				{
					if (size[1] < 0) size[1] = 0;
					node->dispatchSize[1] = size[1];
				}
				ImGui::Text("\t\tWork Group Size Z");
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				if (ImGui::DragInt("##progNodeWorkGroupSizeZ", &size[2], 1.0f))
				{
					if (size[2] < 0) size[2] = 0;
					node->dispatchSize[2] = size[2];
				}
			}
		}
	}

	else if (m_SelectedItemType == SelectedItemType::BUFFER_NODE)
	{
		// Get Selection Id
		int id;
		ImNodes::GetSelectedNodes(&id);
		EditorBlockNodePtr node = std::static_pointer_cast<EditorBlockNode>(m_Nodes[id]);

		bool needsUpdate = false;

		// Add Button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(325);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_var"))
		{
			EditorPinPtr newPin = std::make_shared<EditorFloatPin>();
			newPin->type = EditorPinType::FLOAT;
			newPin->ownerNode = node;
			newPin->name = "new_var" + std::to_string(node->pinsIn.size());
			newPin->id = (int)m_Pins.size();
			m_Pins.push_back(newPin);
			node->pinsIn.push_back(newPin);
			node->size += EditorNodeUtil::PinTypeSize(newPin->type);
			node->pinsOut[0]->size = node->size;
			auto links = node->pinsOut[0]->connectedLinks;
			for (auto& link : links)
			{
				DeleteLink(link->id);
			}
			UpdateLinks();
			needsUpdate = true;
		}
		ImGui::SameLine();
		ImGui::SetCursorPosX(xPos);

		// Title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Variables", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::SameLine();
		ImGui::SetCursorPosX(325);
		ImGui::Text(ICON_FK_PLUS_CIRCLE);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			int pinIndex = 0;
			for (auto& pinIn : node->pinsIn)
			{
				// name
				ImGui::SetNextItemWidth(150);
				std::string idStr = "##buffer_var_name" + std::to_string(pinIn->id);
				ImGui::InputText(idStr.c_str(), &pinIn->name);

				// Type
				int iVar = (int)pinIn->type - 1;
				EditorPinType type = pinIn->type;
				const char* items = "float\0float2\0float3\0float4\0int\0int2\0int3\0int4\0";
				idStr = "##buffer_var_type" + std::to_string(pinIn->id);
				ImGui::SameLine(160);
				ImGui::SetNextItemWidth(150);
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
				if (ImGui::Combo(idStr.c_str(), &iVar, items))
				{
					EditorPinPtr newPin = 0;
					if (iVar == 0)
					{
						newPin = std::make_shared<EditorFloatPin>();
						newPin->type = EditorPinType::FLOAT;
					}
					else if (iVar == 1)
					{
						newPin = std::make_shared<EditorFloat2Pin>();
						newPin->type = EditorPinType::FLOAT2;
					}
					else if (iVar == 2)
					{
						newPin = std::make_shared<EditorFloat3Pin>();
						newPin->type = EditorPinType::FLOAT3;
					}
					else if (iVar == 3)
					{
						newPin = std::make_shared<EditorFloat4Pin>();
						newPin->type = EditorPinType::FLOAT4;
					}
					else if (iVar == 4)
					{
						newPin = std::make_shared<EditorIntPin>();
						newPin->type = EditorPinType::INT;
					}
					else if (iVar == 5)
					{
						newPin = std::make_shared<EditorInt2Pin>();
						newPin->type = EditorPinType::INT2;
					}
					else if (iVar == 6)
					{
						newPin = std::make_shared<EditorInt3Pin>();
						newPin->type = EditorPinType::INT3;
					}
					else if (iVar == 7)
					{
						newPin = std::make_shared<EditorInt4Pin>();
						newPin->type = EditorPinType::INT4;
					}

					if (newPin)
					{
						node->size -= EditorNodeUtil::PinTypeSize(pinIn->type);
						newPin->ownerNode = node;
						newPin->name = pinIn->name;
						newPin->id = pinIn->id;
						int id = pinIn->id;
						DeletePin(pinIn);
						m_Pins[id] = newPin;
						pinIn = newPin;
						node->size += EditorNodeUtil::PinTypeSize(newPin->type);
						node->pinsOut[0]->size = node->size;
						auto links = node->pinsOut[0]->connectedLinks;
						for (auto& link : links)
						{
							DeleteLink(link->id);
						}
						UpdatePins();
						UpdateLinks();
						needsUpdate = true;
					}
				}
				ImGui::PopStyleColor();

				// Delete button
				ImGui::SameLine();
				ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
				ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
				idStr = ICON_FK_TRASH "##block_var" + std::to_string(pinIn->id);
				if (ImGui::SmallButton(idStr.c_str()))
				{
					node->size -= EditorNodeUtil::PinTypeSize(pinIn->type);
					node->pinsOut[0]->size = node->size;
					auto links = node->pinsOut[0]->connectedLinks;
					for (auto& link : links)
						DeleteLink(link->id);
					m_Pins[pinIn->id] = 0;
					DeletePin(pinIn);
					node->pinsIn.erase(node->pinsIn.begin() + pinIndex);
					pinIndex--;
					UpdatePins();
					UpdateLinks();
					needsUpdate = true;
				}
				ImGui::PopStyleColor(3);
				ImGui::PopStyleVar();

				pinIndex++;
			}
		}

		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		isNodeOpened = ImGui::CollapsingHeader("Storage Buffer", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			ImGui::Text("\t\tSize");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			int iVal = node->ssboSize;
			if (ImGui::InputInt("##blockBuffer_Size", &iVal, 0))
			{
				node->ssboSize = iVal;
				needsUpdate = true;
			}
		}

		if (needsUpdate)
		{
			glBindBuffer(GL_UNIFORM_BUFFER, node->ubo);
			glBufferData(GL_UNIFORM_BUFFER, node->size, NULL, GL_DYNAMIC_DRAW);
			glBindBuffer(GL_UNIFORM_BUFFER, 0);
			glBindBuffer(GL_SHADER_STORAGE_BUFFER, node->ssbo);
			glBufferData(GL_SHADER_STORAGE_BUFFER, node->size * node->ssboSize, NULL, GL_DYNAMIC_DRAW);
			glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
		}
	}

	else if (m_SelectedItemType == SelectedItemType::IMAGE_NODE)
	{
		// Get Selection Id
		int id;
		ImNodes::GetSelectedNodes(&id);
		EditorImageNodePtr node = std::static_pointer_cast<EditorImageNode>(m_Nodes[id]);

		bool needsUpdate = false;

		// title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Image Node", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			// Size
			int x = node->sizeX, y = node->sizeY;
			ImGui::Text("\t\tWidth");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			if (ImGui::DragInt("##imageSizeX", &x, 1.0f, 0, 4096))
			{
				if (x < 0) x = 0;
				if (x > 4096) x = 4096;
				node->sizeX = x;

				needsUpdate = true;
			}
			ImGui::Text("\t\tHeight");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			if (ImGui::DragInt("##imageSizeY", &y, 1.0f, 0, 4096))
			{
				if (y < 0) y = 0;
				if (y > 4096) y = 4096;
				node->sizeY = y;

				needsUpdate = true;
			}
		}

		if (needsUpdate)
		{
			glGenTextures(1, &node->texture);
			glBindTexture(GL_TEXTURE_2D, node->texture);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, node->sizeX, node->sizeY, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
			glBindTexture(GL_TEXTURE_2D, 0);
		}
	}

	else if (m_SelectedItemType == SelectedItemType::PINGPONG_NODE)
	{
		// Get Selection Id
		int id;
		ImNodes::GetSelectedNodes(&id);
		EditorPingPongNodePtr node = std::static_pointer_cast<EditorPingPongNode>(m_Nodes[id]);

		// title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Ping-Pong Node", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		// Buffers type
		ImGui::Text("\t\tBuffers Type");
		ImGui::SameLine(160);
		ImGui::SetNextItemWidth(150);
		int iVal = (int)node->pingpongType;
		const char* items = "Block\0Image\0";
		ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
		if (ImGui::Combo("##pingpongNodeBuffersType", &iVal, items))
		{
			if (iVal == 0)
				UpdatePingPongNode(node->id, EditorPingPongNodeType::BUFFER);
			else
				UpdatePingPongNode(node->id, EditorPingPongNodeType::IMAGE);
		}
		ImGui::PopStyleColor();
	}

	ImGui::EndChild();
}

void NodeEditorWindow::DeleteSelectedItem()
{
	if (m_SelectedItemType >= SelectedItemType::NODES)
	{
		int numNodes = ImNodes::NumSelectedNodes();
		int* ids = new int[numNodes];
		ImNodes::GetSelectedNodes(ids);
		for (int i = 0; i < numNodes; i++)
		{
			if (m_Nodes[ids[i]]->type != EditorNodeType::EVENT)
				DeleteNode(ids[i]);
		}
		delete[] ids;

		int numLinks = ImNodes::NumSelectedLinks();
		ids = new int[numLinks];
		ImNodes::GetSelectedLinks(ids);
		for (int i = 0; i < numLinks; i++)
			DeleteLink(ids[i]);
		delete[] ids;

		if (numNodes > 0)
		{
			UpdateNodes();
			UpdatePins();
		}
		UpdateLinks();
	}

	else if (m_SelectedItemType == SelectedItemType::PROGRAM)
		DeleteProgram(m_SelectedItemId);

	else if (m_SelectedItemType == SelectedItemType::FRAMEBUFFER)
		DeleteFramebuffer(m_SelectedItemId);

	else if (m_SelectedItemType == SelectedItemType::TEXTURE)
		DeleteTexture(m_SelectedItemId);

	m_SelectedItemType = SelectedItemType::NONE;
	m_SelectedItemId = -1;
}

void NodeEditorWindow::AddProgram(GlProgramPtr pProgram)
{
	m_Programs.push_back(pProgram);
}

void NodeEditorWindow::DeleteProgram(int ix)
{
	bool needsUpdate = false;
	for (auto& node : m_Nodes)
	{
		if (node->type == EditorNodeType::PROGRAM)
		{
			EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(node);

			if (progNode->target == m_Programs[ix])
			{
				DeleteNode(node->id);
				needsUpdate = true;
			}
		}
	}
	if (needsUpdate)
	{
		UpdateNodes();
		UpdatePins();
		UpdateLinks();
	}

	{
		GlProgramPtr program = m_Programs[ix];

		m_shaderCache->removeGlProgramFromCache(program);
		m_Programs.erase(m_Programs.begin() + ix);
	}
}

void NodeEditorWindow::AddFramebuffer(GlFrameBufferPtr pFramebuffer)
{
	m_Framebuffers.push_back(pFramebuffer);
}

void NodeEditorWindow::DeleteFramebuffer(int ix)
{
	if (ix == 0)
		return;

	bool needsUpdate = false;
	for (auto& node : m_Nodes)
	{
		if (node->type == EditorNodeType::PROGRAM)
		{
			EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(node);
			if (progNode->framebuffer == m_Framebuffers[ix])
			{
				progNode->framebuffer = m_Framebuffers[0];
				SetProgramNodeFramebuffer(progNode, 0);
				needsUpdate = true;
			}
		}
	}
	if (needsUpdate)
	{
		UpdatePins();
		UpdateLinks();
	}

	{
		GlFrameBufferPtr framebuffer= m_Framebuffers[ix];

		framebuffer->disposeFrameBuffer();
		m_Framebuffers.erase(m_Framebuffers.begin() + ix);
	}
}

void NodeEditorWindow::AddTexture(GlTexturePtr pTex)
{
	m_Textures.push_back(pTex);
}

void NodeEditorWindow::DeleteTexture(int ix)
{
	bool needsUpdate = false;
	for (auto& node : m_Nodes)
	{
		if (node->type == EditorNodeType::TEXTURE)
		{
			EditorTextureNodePtr texNode = std::static_pointer_cast<EditorTextureNode>(node);

			if (texNode->target == m_Textures[ix])
			{
				DeleteNode(node->id);
				needsUpdate = true;
			}
		}
	}
	if (needsUpdate)
	{
		UpdateNodes();
		UpdatePins();
		UpdateLinks();
	}

	{
		GlTexturePtr texture= m_Textures[ix];

		texture->disposeTexture();
		m_Textures.erase(m_Textures.begin() + ix);
	}
}

void NodeEditorWindow::UpdateNodes()
{
	for (int i = 0; i < m_Nodes.size(); i++)
	{
		if (!m_Nodes[i])
		{
			m_Nodes.erase(m_Nodes.begin() + i);
			i--;
		}
		else
		{
			const ImVec2* nodePos= (ImVec2* )(&m_Nodes[i]->nodePos);

			m_Nodes[i]->id = i;
			ImNodes::SetNodeScreenSpacePos(m_Nodes[i]->id, *nodePos);
		}
	}
}

void NodeEditorWindow::UpdatePins()
{
	for (int i = 0; i < m_Pins.size(); i++)
	{
		if (!m_Pins[i])
		{
			m_Pins.erase(m_Pins.begin() + i);
			i--;
		}
		else
			m_Pins[i]->id = i;
	}
}

void NodeEditorWindow::UpdateLinks()
{
	for (int i = 0; i < m_Links.size(); i++)
	{
		if (!m_Links[i])
		{
			m_Links.erase(m_Links.begin() + i);
			i--;
		}
		else
		{
			m_Links[i]->id = i;
		}
	}
}

void NodeEditorWindow::DeletePin(EditorPinPtr pin)
{
	for (auto& link : pin->connectedLinks)
	{
		if (!link) continue;
		EditorPinPtr connectedPin = link->pPin1 == pin ? link->pPin2 : link->pPin1;
		auto& links = connectedPin->connectedLinks;
		links.erase(std::remove(links.begin(), links.end(), link), links.end());
		m_Links[link->id].reset();
	}

	m_Pins[pin->id].reset();
}

void NodeEditorWindow::DeleteNodePinsAndLinks(int id)
{
	for (auto& pin : m_Nodes[id]->pinsIn)
	{
		if (!pin) continue;
		DeletePin(pin);
	}
	for (auto& pin : m_Nodes[id]->pinsOut)
	{
		if (!pin) continue;
		DeletePin(pin);
	}
}

void NodeEditorWindow::DeleteNode(int id)
{
	ImNodes::ClearNodeSelection();
	m_SelectedItemType = SelectedItemType::NONE;
	m_SelectedItemId = -1;
	DeleteNodePinsAndLinks(id);
	m_Nodes[id].reset();
}

void NodeEditorWindow::DeleteLink(int id, bool checkPingPongNodes)
{
	ImNodes::ClearLinkSelection();
	m_SelectedItemType = SelectedItemType::NONE;
	m_SelectedItemId = -1;

	EditorLinkPtr link = m_Links[id];
	if (!link) return;

	auto& links1 = link->pPin1->connectedLinks;
	links1.erase(std::remove(links1.begin(), links1.end(), link), links1.end());
	if (link->pPin1->ownerNode->type == EditorNodeType::PINGPONG &&
		link->pPin1->type == EditorPinType::BLOCK && checkPingPongNodes)
	{
		auto node = (EditorPingPongNode*)link->pPin1->ownerNode.get();
		bool isEmpty = true;
		for (auto& pin : node->pinsIn)
		{
			if (pin->connectedLinks.size() > 0)
			{
				isEmpty = false;
				break;
			}
		}
		for (auto& pin : node->pinsOut)
		{
			if (pin->connectedLinks.size() > 0)
			{
				isEmpty = false;
				break;
			}
		}
		if (isEmpty)
		{
			node->size = 0;
			for (auto& pin : node->pinsIn)
				pin->size = 0;
			for (auto& pin : node->pinsOut)
				pin->size = 0;
		}
	}

	auto& links2 = link->pPin2->connectedLinks;
	links2.erase(std::remove(links2.begin(), links2.end(), link), links2.end());
	if (link->pPin2->ownerNode->type == EditorNodeType::PINGPONG &&
		link->pPin2->type == EditorPinType::BLOCK && checkPingPongNodes)
	{
		auto node = (EditorPingPongNode*)link->pPin2->ownerNode.get();
		bool isEmpty = true;
		for (auto& pin : node->pinsIn)
		{
			if (pin->connectedLinks.size() > 0)
			{
				isEmpty = false;
				break;
			}
		}
		for (auto& pin : node->pinsOut)
		{
			if (pin->connectedLinks.size() > 0)
			{
				isEmpty = false;
				break;
			}
		}
		if (isEmpty)
		{
			node->size = 0;
			for (auto& pin : node->pinsIn)
				pin->size = 0;
			for (auto& pin : node->pinsOut)
				pin->size = 0;
		}
	}

	m_Links[id].reset();
}

void NodeEditorWindow::CreateLink(int startPinId, int endPinId)
{
	bool canCreateLink = false;
	if (m_Pins[startPinId]->type == m_Pins[endPinId]->type)
	{
		if (m_Pins[startPinId]->type == EditorPinType::FLOW)
		{
			bool needsUpdate = false;
			if (m_Pins[startPinId]->connectedLinks.size() > 0)
			{
				DeleteLink(m_Pins[startPinId]->connectedLinks[0]->id);
				needsUpdate = true;
			}
			if (m_Pins[endPinId]->connectedLinks.size() > 0)
			{
				DeleteLink(m_Pins[endPinId]->connectedLinks[0]->id);
				needsUpdate = true;
			}
			if (needsUpdate)
				UpdateLinks();
			canCreateLink = true;
		}
		else if (m_Pins[startPinId]->type == EditorPinType::BLOCK)
		{
			if (m_Pins[startPinId]->size == m_Pins[endPinId]->size)
			{
				if (!m_Pins[startPinId]->isOutput)
				{
					if (m_Pins[startPinId]->connectedLinks.size() > 0)
					{
						DeleteLink(m_Pins[startPinId]->connectedLinks[0]->id);
						UpdateLinks();
					}
				}
				if (!m_Pins[endPinId]->isOutput)
				{
					if (m_Pins[endPinId]->connectedLinks.size() > 0)
					{
						DeleteLink(m_Pins[endPinId]->connectedLinks[0]->id);
						UpdateLinks();
					}
				}
				canCreateLink = true;
			}
			else
			{
				bool needsUpdate = false;
				if (!m_Pins[startPinId]->isOutput)
				{
					if (m_Pins[startPinId]->connectedLinks.size() > 0)
					{
						DeleteLink(m_Pins[startPinId]->connectedLinks[0]->id);
						needsUpdate = true;
					}
				}
				if (!m_Pins[endPinId]->isOutput)
				{
					if (m_Pins[endPinId]->connectedLinks.size() > 0)
					{
						DeleteLink(m_Pins[endPinId]->connectedLinks[0]->id);
						needsUpdate = true;
					}
				}
				if ((m_Pins[startPinId]->ownerNode->type == EditorNodeType::PINGPONG
					 && m_Pins[startPinId]->size == 0))
				{
					auto pingpongNode = (EditorPingPongNode*)m_Pins[startPinId]->ownerNode.get();
					pingpongNode->size = m_Pins[endPinId]->size;
					auto pin = pingpongNode->pinsIn[0];
					pin->size = m_Pins[endPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsIn[1];
					pin->size = m_Pins[endPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsOut[0];
					pin->size = m_Pins[endPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsOut[1];
					pin->size = m_Pins[endPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					canCreateLink = true;
				}
				else if (m_Pins[endPinId]->ownerNode->type == EditorNodeType::PINGPONG
						 && m_Pins[endPinId]->size == 0)
				{
					auto pingpongNode = (EditorPingPongNode*)m_Pins[endPinId]->ownerNode.get();
					pingpongNode->size = m_Pins[startPinId]->size;
					auto pin = pingpongNode->pinsIn[0];
					pin->size = m_Pins[startPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsIn[1];
					pin->size = m_Pins[startPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsOut[0];
					pin->size = m_Pins[startPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					pin = pingpongNode->pinsOut[1];
					pin->size = m_Pins[startPinId]->size;
					for (auto& link : pin->connectedLinks)
					{
						DeleteLink(link->id, false);
						needsUpdate = true;
					}
					canCreateLink = true;
				}
				if (needsUpdate)
					UpdateLinks();
			}
		}
		else
		{
			if (!m_Pins[startPinId]->isOutput)
			{
				if (m_Pins[startPinId]->connectedLinks.size() > 0)
				{
					DeleteLink(m_Pins[startPinId]->connectedLinks[0]->id);
					UpdateLinks();
				}
			}
			if (!m_Pins[endPinId]->isOutput)
			{
				if (m_Pins[endPinId]->connectedLinks.size() > 0)
				{
					DeleteLink(m_Pins[endPinId]->connectedLinks[0]->id);
					UpdateLinks();
				}
			}
			canCreateLink = true;
		}
	}

	if (canCreateLink)
	{
		EditorLinkPtr link = std::make_shared<EditorLink>();

		link->id = (int)m_Links.size();
		link->pPin1 = m_Pins[startPinId];
		link->pPin2 = m_Pins[endPinId];
		m_Pins[startPinId]->connectedLinks.push_back(link);
		m_Pins[endPinId]->connectedLinks.push_back(link);
		m_Links.push_back(link);
	}
}

ImNodesPinShape NodeEditorWindow::BeginPin(EditorPinPtr pin, float alpha)
{
	ImNodesPinShape pinShape = ImNodesPinShape_Triangle;
	if (pin->type == EditorPinType::FLOW)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_TriangleFilled;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(225, 225, 225, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(255, 255, 255, alpha * 255));
	}
	else if (pin->type == EditorPinType::INT)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(33, 227, 175, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(135, 239, 195, alpha * 255));
	}
	else if (pin->type == EditorPinType::FLOAT)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(156, 253, 65, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(144, 225, 137, alpha * 255));
	}
	else if (pin->type == EditorPinType::BLOCK)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(6, 165, 239, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(137, 196, 247, alpha * 255));
	}
	else if (pin->type == EditorPinType::TEXTURE)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(148, 0, 0, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(183, 137, 137, alpha * 255));
	}
	else if (pin->type == EditorPinType::IMAGE)
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(200, 130, 255, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(220, 170, 255, alpha * 255));
	}
	else
	{
		if (pin->connectedLinks.size() > 0)
			pinShape = ImNodesPinShape_CircleFilled;
		else
			pinShape = ImNodesPinShape_Circle;
		ImNodes::PushColorStyle(ImNodesCol_Pin, IM_COL32(252, 200, 35, alpha * 255));
		ImNodes::PushColorStyle(ImNodesCol_PinHovered, IM_COL32(255, 217, 140, alpha * 255));
	}

	return pinShape;
}

void NodeEditorWindow::EndPin()
{
	ImNodes::PopColorStyle();
	ImNodes::PopColorStyle();
}

void NodeEditorWindow::InputPin(EditorNodePtr node, EditorPinPtr pin)
{
	float alpha = 0.2f;
	if (m_StartedLinkPinId == -1)
		alpha = 1.0f;
	else
	{
		if (m_StartedLinkPinId == pin->id ||
			(m_Pins[m_StartedLinkPinId]->type == pin->type
			 && m_Pins[m_StartedLinkPinId]->isOutput
			 && m_Pins[m_StartedLinkPinId]->ownerNode != node))
		{
			if (m_Pins[m_StartedLinkPinId]->size == pin->size)
				alpha = 1.0f;
			else if ((m_Pins[m_StartedLinkPinId]->ownerNode->type == EditorNodeType::PINGPONG
					  && m_Pins[m_StartedLinkPinId]->size == 0) ||
					 (node->type == EditorNodeType::PINGPONG && pin->size == 0))
				alpha = 1.0f;
		}
	}
	ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, alpha));

	ImNodesPinShape pinShape = BeginPin(pin, alpha);

	ImNodes::BeginInputAttribute(pin->id, pinShape);
	ImGui::Dummy(ImVec2(11.0f, 1.0f));
	ImGui::SameLine();
	ImGui::Text(pin->name.c_str());
	if (pin->type == EditorPinType::FLOAT)
	{
		EditorFloatPinPtr p = std::static_pointer_cast<EditorFloatPin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::SameLine();
			ImGui::SetNextItemWidth(50.0f);
			ImGui::InputFloat("", &p->value);
		}
	}
	if (pin->type == EditorPinType::INT)
	{
		EditorIntPinPtr p = std::static_pointer_cast<EditorIntPin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::SameLine();
			ImGui::SetNextItemWidth(50.0f);
			ImGui::InputInt("", &p->value, 0);
		}
	}
	else if (pin->type == EditorPinType::FLOAT2)
	{
		EditorFloat2PinPtr p = std::static_pointer_cast<EditorFloat2Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(100.0f);
			ImGui::InputFloat2("", p->value);
		}
	}
	else if (pin->type == EditorPinType::INT2)
	{
		EditorInt2PinPtr p = std::static_pointer_cast<EditorInt2Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(100.0f);
			ImGui::InputInt2("", p->value);
		}
	}
	else if (pin->type == EditorPinType::FLOAT3)
	{
		EditorFloat3PinPtr p = std::static_pointer_cast<EditorFloat3Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(150.0f);
			ImGui::InputFloat3("", p->value);
		}
	}
	else if (pin->type == EditorPinType::INT3)
	{
		EditorInt3PinPtr p = std::static_pointer_cast<EditorInt3Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(150.0f);
			ImGui::InputInt3("", p->value);
		}
	}
	else if (pin->type == EditorPinType::FLOAT4)
	{
		EditorFloat4PinPtr p = std::static_pointer_cast<EditorFloat4Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(200.0f);
			ImGui::InputFloat4("", p->value);
		}
	}
	else if (pin->type == EditorPinType::INT4)
	{
		EditorInt4PinPtr p = std::static_pointer_cast<EditorInt4Pin>(pin);
		if (pin->connectedLinks.size() == 0)
		{
			ImGui::Dummy(ImVec2(11.0f, 1.0f));
			ImGui::SameLine();
			ImGui::SetNextItemWidth(200.0f);
			ImGui::InputInt4("", p->value);
		}
	}
	ImNodes::EndInputAttribute();

	EndPin();

	ImGui::PopStyleColor();
}

void NodeEditorWindow::OutputPin(EditorNodePtr node, EditorPinPtr pin)
{
	float alpha = 0.2f;
	if (m_StartedLinkPinId == -1)
		alpha = 1.0f;
	else
	{
		if (m_StartedLinkPinId == pin->id ||
			(m_Pins[m_StartedLinkPinId]->type == pin->type
			 && !m_Pins[m_StartedLinkPinId]->isOutput
			 && m_Pins[m_StartedLinkPinId]->ownerNode != node))
		{
			if (m_Pins[m_StartedLinkPinId]->size == pin->size)
				alpha = 1.0f;
			else if ((m_Pins[m_StartedLinkPinId]->ownerNode->type == EditorNodeType::PINGPONG
					  && m_Pins[m_StartedLinkPinId]->size == 0) ||
					 (node->type == EditorNodeType::PINGPONG && pin->size == 0))
				alpha = 1.0f;
		}
	}
	ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, alpha));

	ImNodesPinShape pinShape = BeginPin(pin, alpha);

	ImNodes::BeginOutputAttribute(pin->id, pinShape);
	std::string name = " " + pin->name;
	ImGui::Text(name.c_str());
	ImGui::SameLine();
	ImGui::Dummy(ImVec2(11.0f, 1.0f));
	ImNodes::EndOutputAttribute();

	EndPin();

	ImGui::PopStyleColor();
}

EditorPinPtr NodeEditorWindow::GetConnectedPin(EditorNodePtr node, EditorLinkPtr link)
{
	return (link->pPin1->ownerNode == node) ? link->pPin2 : link->pPin1;
}

void NodeEditorWindow::GetInputTargetNode(EditorNodePtr& connectedNode, EditorPinType type, int index)
{
	EditorNodeType targetNodeType =
		type == EditorPinType::IMAGE ? EditorNodeType::IMAGE : EditorNodeType::BLOCK;
	while (connectedNode && connectedNode->type != targetNodeType)
	{
		if (connectedNode->type == EditorNodeType::PINGPONG)
		{
			auto pingpongNode = std::static_pointer_cast<EditorPingPongNode>(connectedNode);
			if (m_PingPongSwap)
			{
				if (pingpongNode->pinsIn[1]->connectedLinks.size() > 0)
				{
					connectedNode = GetConnectedPin
					(
						pingpongNode,
						pingpongNode->pinsIn[1]->connectedLinks[0]
					)->ownerNode;
				}
				else
				{
					connectedNode = 0;
					break;
				}
			}
			else
			{
				if (pingpongNode->pinsIn[0]->connectedLinks.size() > 0)
				{
					connectedNode = GetConnectedPin
					(
						pingpongNode,
						pingpongNode->pinsIn[0]->connectedLinks[0]
					)->ownerNode;
				}
				else
				{
					connectedNode = 0;
					break;
				}
			}
		}
		else if (connectedNode->type == EditorNodeType::PROGRAM)
		{
			auto progNode = std::static_pointer_cast<EditorProgramNode>(connectedNode);
			if (targetNodeType == EditorNodeType::IMAGE)
			{
				int pinIndex = 0;
				for (auto& pin : progNode->pinsIn)
				{
					if (pin->type == EditorPinType::IMAGE)
					{
						if (pinIndex == index)
						{
							if (pin->connectedLinks.size() > 0)
							{
								connectedNode = GetConnectedPin
								(
									progNode,
									pin->connectedLinks[0]
								)->ownerNode;
							}
							else
							{
								connectedNode = 0;
								break;
							}
						}
						pinIndex++;
					}
				}
			}
			else
			{
				int pinIndex = 0;
				for (auto& pin : progNode->pinsIn)
				{
					if (pin->type == EditorPinType::BLOCK)
					{
						EditorBlockPinPtr blockPin = std::static_pointer_cast<EditorBlockPin>(pin);
						if (blockPin->blockPinType == EditorBlockPinType::BUFFER_BLOCK)
						{
							if (pinIndex == index)
							{
								if (pin->connectedLinks.size() > 0)
								{
									connectedNode = GetConnectedPin
									(
										progNode,
										pin->connectedLinks[0]
									)->ownerNode;
								}
								else
								{
									connectedNode = 0;
									break;
								}
							}
							pinIndex++;
						}
					}
				}
			}
		}
		else
		{
			connectedNode = 0;
			break;
		}
	}
}

void NodeEditorWindow::ExecuteProgramNode(EditorProgramNodePtr progNode)
{
	// Setup program
	//glUseProgram(progNode->target->bindProgram());
	progNode->target->bindProgram();

	if (progNode->dispatchType == EditorProgramDispatchType::ARRAY)
	{
		auto framebuffer = progNode->framebuffer->getFramebuffer();
		glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
		if (framebuffer == 0)
		{
			glViewport(0, 0, (int)getWidth(), (int)getHeight());
		}
		else
		{
			int width, height;
			progNode->framebuffer->getSize(&width, &height);
			glViewport(0, 0, width, height);

			int numAttachments = progNode->framebuffer->getNumAttachments();
			GLenum* attachments = new GLenum[numAttachments];
			for (int i = 0; i < numAttachments; i++)
				attachments[i] = GL_COLOR_ATTACHMENT0 + i;
			glDrawBuffers(numAttachments, attachments);
			delete[] attachments;
		}
		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	}

	int imageCount = 0;
	int uniformBlockIndex = 0;
	int storageBufferIndex = 0;

	// Handle inputs
	for (auto& pin : progNode->pinsIn)
	{
		if (pin->type == EditorPinType::FLOAT)
		{
			if (pin->connectedLinks.size() > 0)
			{
				EditorNodePtr connectedNode = GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
				if (connectedNode->type == EditorNodeType::TIME)
				{
					auto currentTime = std::chrono::high_resolution_clock::now();
					float value =
						std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - m_StartTime).count();
					value *= 0.001f;
					progNode->target->setFloatUniform(pin->name, value);
				}
			}
			else
			{
				EditorFloatPinPtr p = std::static_pointer_cast<EditorFloatPin>(pin);
				progNode->target->setFloatUniform(pin->name, p->value);
			}
		}
		else if (pin->type == EditorPinType::FLOAT2)
		{
			if (pin->connectedLinks.size() > 0)
			{
				EditorNodePtr connectedNode = GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
				if (connectedNode->type == EditorNodeType::MOUSE_POS)
				{
					auto mousePos = ImGui::GetMousePos();
					const glm::vec2 value(mousePos.x / getWidth(), mousePos.y / getHeight());
					progNode->target->setVector2Uniform(pin->name, value);
				}
			}
			else
			{
				EditorFloat2PinPtr p = std::static_pointer_cast<EditorFloat2Pin>(pin);
				const glm::vec2 value(p->value[0], p->value[1]);
				progNode->target->setVector2Uniform(pin->name, value);
			}
		}
		else if (pin->type == EditorPinType::FLOAT3)
		{
			EditorFloat3PinPtr p = std::static_pointer_cast<EditorFloat3Pin>(pin);
			const glm::vec3 value(p->value[0], p->value[1], p->value[2]);
			progNode->target->setVector3Uniform(pin->name, value);
		}
		else if (pin->type == EditorPinType::FLOAT4)
		{
			EditorFloat4PinPtr p = std::static_pointer_cast<EditorFloat4Pin>(pin);
			const glm::vec4 value(p->value[0], p->value[1], p->value[2], p->value[3]);
			progNode->target->setVector4Uniform(pin->name, value);
		}
		else if (pin->type == EditorPinType::INT)
		{
			EditorIntPinPtr p = std::static_pointer_cast<EditorIntPin>(pin);
			progNode->target->setIntUniform(pin->name, p->value);
		}
		else if (pin->type == EditorPinType::INT2)
		{
			EditorInt2PinPtr p = std::static_pointer_cast<EditorInt2Pin>(pin);
			const glm::ivec2 value(p->value[0], p->value[1]);
			progNode->target->setInt2Uniform(pin->name, value);

		}
		else if (pin->type == EditorPinType::INT3)
		{
			EditorInt3PinPtr p = std::static_pointer_cast<EditorInt3Pin>(pin);
			const glm::ivec3 value(p->value[0], p->value[1], p->value[2]);
			progNode->target->setInt3Uniform(pin->name, value);
		}
		else if (pin->type == EditorPinType::INT4)
		{
			EditorInt4PinPtr p = std::static_pointer_cast<EditorInt4Pin>(pin);
			const glm::ivec4 value(p->value[0], p->value[1], p->value[2], p->value[3]);
			progNode->target->setInt4Uniform(pin->name, value);
		}

		else if (pin->type == EditorPinType::TEXTURE)
		{
			if (pin->connectedLinks.size() > 0)
			{
				GLuint texture = -1;

				auto connectedNode = GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
				if (connectedNode->type == EditorNodeType::PROGRAM)
				{
					auto connectedProgNode = std::static_pointer_cast<EditorProgramNode>(connectedNode);
					auto connectedPin = GetConnectedPin(progNode, pin->connectedLinks[0]);
					int attachmentIndex = connectedProgNode->attachmentsPinsStartId;
					for (int i = attachmentIndex; i < connectedProgNode->pinsOut.size(); i++)
					{
						if (connectedProgNode->pinsOut[i] == connectedPin)
							break;
						attachmentIndex++;
					}

					texture = connectedProgNode->framebuffer->getTexture(attachmentIndex);
				}
				else if (connectedNode->type == EditorNodeType::TEXTURE)
				{
					auto texNode = std::static_pointer_cast<EditorTextureNode>(connectedNode);

					texture = texNode->target->getGlTextureId();
				}
				else if (connectedNode->type == EditorNodeType::IMAGE)
				{
					auto imgNode = std::static_pointer_cast<EditorImageNode>(connectedNode);

					if (imgNode->pinsIn[0]->connectedLinks.size() > 0)
					{
						auto texNode = 
							std::static_pointer_cast<EditorTextureNode>(
								GetConnectedPin(imgNode, imgNode->pinsIn[0]->connectedLinks[0])->ownerNode);
						texture = texNode->target->getGlTextureId();
					}
					else
					{
						texture = imgNode->texture;
					}
				}

				if (texture != -1)
				{
					int textureUnit;
					if (progNode->target->getUniformTextureUnit(pin->name, textureUnit))
					{
						glActiveTexture(GL_TEXTURE0 + textureUnit);
						glBindTexture(GL_TEXTURE_2D, texture);

						progNode->target->setTextureUniform(pin->name);
					}
				}
			}
		}

		else if (pin->type == EditorPinType::IMAGE)
		{
			if (pin->connectedLinks.size() > 0)
			{
				EditorNodePtr connectedNode = GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
				GetInputTargetNode(connectedNode, EditorPinType::IMAGE, imageCount);

				if (connectedNode)
				{
					EditorImageNodePtr imgNode = std::static_pointer_cast<EditorImageNode>(connectedNode);

					int textureUnit;
					if (progNode->target->getUniformTextureUnit(pin->name, textureUnit))
					{
						if (imgNode->pinsIn[0]->connectedLinks.size() > 0)
						{
							EditorTextureNodePtr texNode =
								std::static_pointer_cast<EditorTextureNode>(
									GetConnectedPin(imgNode, imgNode->pinsIn[0]->connectedLinks[0])->ownerNode);
							//glBindTexture(GL_TEXTURE_2D, texNode->target->GetTexture());
							glBindImageTexture(textureUnit, texNode->target->getGlTextureId(), 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA8);
						}
						else
						{
							//glBindTexture(GL_TEXTURE_2D, imgNode->texture);
							glBindImageTexture(textureUnit, imgNode->texture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA8);
						}

						progNode->target->setTextureUniform(pin->name);
					}
				}
			}
			imageCount++;
		}

		else if (pin->type == EditorPinType::BLOCK)
		{
			EditorBlockPinPtr p = std::static_pointer_cast<EditorBlockPin>(pin);
			if (pin->connectedLinks.size() > 0)
			{
				EditorNodePtr connectedNode = GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
				GetInputTargetNode(connectedNode, EditorPinType::BLOCK, storageBufferIndex);

				if (connectedNode)
				{
					EditorBlockNodePtr blockNode = 
						std::static_pointer_cast<EditorBlockNode>(
							GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode);
					if (p->blockPinType == EditorBlockPinType::UNIFROM_BLOCK)
					{
						// TODO: Write uniform block bind wrapper on GlProgram class instead
						GLuint blockId =
							glGetUniformBlockIndex(progNode->target->getGlProgramId(), pin->name.c_str());
						GLuint binding = progNode->target->GetUniformBlocks()[uniformBlockIndex].GetBinding();
						glUniformBlockBinding(progNode->target->getGlProgramId(), blockId, binding);
						glBindBufferBase(GL_UNIFORM_BUFFER, binding, blockNode->ubo);

						GLubyte* blockData = (GLubyte*)glMapBufferRange
						(
							GL_UNIFORM_BUFFER, 0, blockNode->size,
							GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT
						);
						int offset = 0;
						for (int i = 0; i < blockNode->pinsIn.size(); i++)
						{
							if (blockNode->pinsIn[i]->type == EditorPinType::FLOAT)
							{
								if (blockNode->pinsIn[i]->connectedLinks.size() > 0)
								{
									EditorNodePtr connectedNode =
										GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
									if (connectedNode->type == EditorNodeType::TIME)
									{
										auto currentTime = std::chrono::high_resolution_clock::now();
										float value =
											std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - m_StartTime).count();
										value *= 0.001f;
										memcpy(blockData + offset, &value, sizeof(float));
									}
								}
								else
								{
									auto blockPin = std::static_pointer_cast<EditorFloatPin>(blockNode->pinsIn[i]);
									memcpy(blockData + offset, &blockPin->value, sizeof(float));
								}
								offset += sizeof(float);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::FLOAT2)
							{
								if (blockNode->pinsIn[i]->connectedLinks.size() > 0)
								{
									EditorNodePtr connectedNode =
										GetConnectedPin(progNode, pin->connectedLinks[0])->ownerNode;
									if (connectedNode->type == EditorNodeType::MOUSE_POS)
									{
										auto mousePos = ImGui::GetMousePos();
										float x = mousePos.x / getWidth();
										memcpy(blockData + offset, &x, sizeof(float));
										offset += sizeof(float);
										float y = mousePos.y / getHeight();
										memcpy(blockData + offset, &y, sizeof(float));
										offset += sizeof(float);
									}
								}
								else
								{
									auto blockPin = std::static_pointer_cast<EditorFloat2Pin>(blockNode->pinsIn[i]);
									memcpy(blockData + offset, &blockPin->value[0], sizeof(float));
									offset += sizeof(float);
									memcpy(blockData + offset, &blockPin->value[1], sizeof(float));
									offset += sizeof(float);
								}
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::FLOAT3)
							{
								auto blockPin = std::static_pointer_cast<EditorFloat3Pin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value[0], sizeof(float));
								offset += sizeof(float);
								memcpy(blockData + offset, &blockPin->value[1], sizeof(float));
								offset += sizeof(float);
								memcpy(blockData + offset, &blockPin->value[2], sizeof(float));
								offset += sizeof(float);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::FLOAT4)
							{
								auto blockPin = std::static_pointer_cast<EditorFloat4Pin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value[0], sizeof(float));
								offset += sizeof(float);
								memcpy(blockData + offset, &blockPin->value[1], sizeof(float));
								offset += sizeof(float);
								memcpy(blockData + offset, &blockPin->value[2], sizeof(float));
								offset += sizeof(float);
								memcpy(blockData + offset, &blockPin->value[3], sizeof(float));
								offset += sizeof(float);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::INT)
							{
								auto blockPin = std::static_pointer_cast<EditorIntPin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value, sizeof(int));
								offset += sizeof(int);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::INT2)
							{
								auto blockPin = std::static_pointer_cast<EditorInt2Pin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value[0], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[1], sizeof(int));
								offset += sizeof(int);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::INT3)
							{
								auto blockPin = std::static_pointer_cast<EditorInt3Pin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value[0], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[1], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[2], sizeof(int));
								offset += sizeof(int);
							}
							else if (blockNode->pinsIn[i]->type == EditorPinType::INT4)
							{
								auto blockPin = std::static_pointer_cast<EditorInt4Pin>(blockNode->pinsIn[i]);
								memcpy(blockData + offset, &blockPin->value[0], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[1], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[2], sizeof(int));
								offset += sizeof(int);
								memcpy(blockData + offset, &blockPin->value[3], sizeof(int));
								offset += sizeof(int);
							}
						}

						// TODO: Write uniform block unbind wrapper on GlProgram class instead
						glUnmapBuffer(GL_UNIFORM_BUFFER);
					}
					else
					{
						// TODO: Write shader storage bind/unbind wrapper on GlProgram class instead
						glBindBuffer(GL_SHADER_STORAGE_BUFFER, blockNode->ssbo);
						GLuint binding = progNode->target->GetBufferBlocks()[storageBufferIndex].GetBinding();
						glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding, blockNode->ssbo);
					}
				}
			}

			if (p->blockPinType == EditorBlockPinType::UNIFROM_BLOCK)
				uniformBlockIndex++;
			else
				storageBufferIndex++;
		}
	}

	// Dispatch
	if (progNode->dispatchType == EditorProgramDispatchType::ARRAY)
	{
		glDrawArrays(progNode->drawMode, 0, progNode->dispatchSize[0]);
	}
	else if (progNode->dispatchType == EditorProgramDispatchType::COMPUTE)
	{
		glDispatchCompute
		(
			progNode->dispatchSize[0],
			progNode->dispatchSize[1],
			progNode->dispatchSize[2]
		);
		glMemoryBarrier
		(
			GL_SHADER_IMAGE_ACCESS_BARRIER_BIT |
			GL_SHADER_STORAGE_BARRIER_BIT |
			GL_BUFFER_UPDATE_BARRIER_BIT
		);
	}
}

void NodeEditorWindow::shutdown()
{
	m_glStateStack = nullptr;

	if (m_shaderCache != nullptr)
	{
		m_shaderCache->shutdown();
		m_shaderCache = nullptr;
	}

	if (m_imnodesContext != nullptr)
	{
		ImNodes::DestroyContext(m_imnodesContext);
		m_imnodesContext= nullptr;
	}

	if (m_imguiOpenGLBackendInitialised)
	{
		ImGui_ImplOpenGL3_Shutdown();
		m_imguiOpenGLBackendInitialised = false;
	}

	if (m_imguiSDLBackendInitialised)
	{
		ImGui_ImplSDL2_Shutdown();
		m_imguiSDLBackendInitialised = false;
	}

	if (m_imguiContext != nullptr)
	{
		ImGui::DestroyContext(m_imguiContext);
		m_imguiContext = nullptr;
	}

	if (m_sdlWindow != nullptr)
	{
		m_sdlWindow->shutdown();
		m_sdlWindow = nullptr;
	}
}

float NodeEditorWindow::getWidth() const
{
	return (float)m_sdlWindow->getWidth();
}

float NodeEditorWindow::getHeight() const
{
	return (float)m_sdlWindow->getHeight();
}

float NodeEditorWindow::getAspectRatio() const
{
	return (float)m_sdlWindow->getAspectRatio();
}

bool NodeEditorWindow::onSDLEvent(const SDL_Event* event)
{
	m_sdlWindow->onSDLEvent(event);

	return ImGui_ImplSDL2_ProcessEvent(event);
}

void NodeEditorWindow::configImGui()
{
	ImGuiIO& io = ImGui::GetIO();

	io.Fonts->AddFontFromFileTTF(
		getDefaultJapaneseFontPath().string().c_str(), 16, NULL, io.Fonts->GetGlyphRangesJapanese());
	//TODO: Find these fonts
	//io.Fonts->AddFontFromFileTTF(getDefaultKoreanFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesKorean();
	//io.Fonts->AddFontFromFileTTF(getDefaultChineseFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesChineseFull();
	//io.Fonts->AddFontFromFileTTF(getDefaultCyrillicFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesCyrillic();
	//io.Fonts->AddFontFromFileTTF(getDefaultThaiFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesThai();
	//io.Fonts->AddFontFromFileTTF(getDefaultVietnameseFontPath().c_str(), 16, NULL, io.Fonts->GetGlyphRangesVietnamese();

	// Setup Dear ImGui style
	ImGui::StyleColorsDark();

	static const ImWchar icons_ranges[] = {ICON_MIN_FK, ICON_MAX_FK, 0};
	ImFontConfig icons_config;
	icons_config.MergeMode = true;
	icons_config.PixelSnapH = true;
	
	m_NormalIconFont = io.Fonts->AddFontFromFileTTF(
		getForkAwesomeWebFontPath().string().c_str(),
		14, &icons_config, icons_ranges);

	icons_config.GlyphOffset.y += (22 - 17) * 0.5f;
	m_BigIconFont = io.Fonts->AddFontFromFileTTF(
		getForkAwesomeWebFontPath().string().c_str(),
		22, &icons_config, icons_ranges);
}

void NodeEditorWindow::configImNodes()
{
	ImNodes::GetIO().AltMouseButton = ImGuiMouseButton_Right;

	ImNodes::GetStyle().NodePadding = ImVec2(12.0f, 5.0f);
	ImNodes::GetStyle().PinOffset = -16.0f;
	ImNodes::GetStyle().PinCircleRadius = 5.0f;
	ImNodes::GetStyle().NodeCornerRounding = 6.0f;
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackground] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(24, 24, 24, 200);
	ImNodes::GetStyle().Colors[ImNodesCol_GridBackground] = IM_COL32(38, 38, 38, 255);
	ImNodes::GetStyle().Colors[ImNodesCol_GridLine] = IM_COL32(53, 53, 53, 255);
}

void NodeEditorWindow::pushImGuiStyles()
{
	ImGui::PushFont(m_NormalIconFont);

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(6, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(8, 2));
	ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 6));
	ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 12);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1);
	ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3);
	ImGui::PushStyleVar(ImGuiStyleVar_GrabRounding, 2);

	ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.94f, 0.94f, 0.94f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TextDisabled, ImVec4(0.66f, 0.66f, 0.66f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImVec4(0.4f, 0.4f, 0.4f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_TitleBg, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TitleBgActive, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TitleBgCollapsed, ImVec4(0.18f, 0.18f, 0.18f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_MenuBarBg, ImVec4(0.06f, 0.06f, 0.06f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ScrollbarBg, ImVec4(0.1f, 0.1f, 0.1f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Tab, ImVec4(0.06f, 0.06f, 0.06f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TabHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_TabActive, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGrip, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGripHovered, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_ResizeGripActive, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_SeparatorActive, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_DragDropTarget, ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
}

void NodeEditorWindow::popImGuiStyles()
{
	ImGui::PopFont();
	ImGui::PopStyleVar(7);
	ImGui::PopStyleColor(26);
}

// TODO: Move to Nodes
EditorPinPtr NodeEditorWindow::AllocPin(const GlProgramUniform& uniform)
{
	EditorPinPtr pin;

	eUniformDataType uniformDataType= GlProgram::getUniformSemanticDataType(uniform.semantic);
	switch (uniformDataType)
	{
		case eUniformDataType::datatype_float:
			pin = std::make_shared<EditorFloatPin>();
			break;
		case eUniformDataType::datatype_float2:
			pin = std::make_shared<EditorFloat2Pin>();
			break;
		case eUniformDataType::datatype_float3:
			pin = std::make_shared<EditorFloat3Pin>();
			break;
		case eUniformDataType::datatype_float4:
			pin = std::make_shared<EditorFloat4Pin>();
			break;
		case eUniformDataType::datatype_int:
			pin = std::make_shared<EditorIntPin>();
			break;
		case eUniformDataType::datatype_int2:
			pin = std::make_shared<EditorInt2Pin>();
			break;
		case eUniformDataType::datatype_int3:
			pin = std::make_shared<EditorInt3Pin>();
			break;
		case eUniformDataType::datatype_int4:
			pin = std::make_shared<EditorInt4Pin>();
			break;
		case eUniformDataType::datatype_mat4:
			pin = std::make_shared<EditorMat4Pin>();
			break;
		case eUniformDataType::datatype_texture:
			//TODO
			//pin = std::make_shared<EditorTexturePin>();
			break;
		default:
			pin = std::make_shared<EditorPin>();
	}

	return pin;
}

EditorPinPtr NodeEditorWindow::AllocPin(const GlShaderVar& var)
{
	auto type = EditorNodeUtil::GLTypeToPinType(var.GetType());
	EditorPinPtr pin;
	if (type == EditorPinType::FLOAT)
		pin = std::make_shared<EditorFloatPin>();
	else if (type == EditorPinType::FLOAT2)
		pin = std::make_shared<EditorFloat2Pin>();
	else if (type == EditorPinType::FLOAT3)
		pin = std::make_shared<EditorFloat3Pin>();
	else if (type == EditorPinType::FLOAT4)
		pin = std::make_shared<EditorFloat4Pin>();
	else if (type == EditorPinType::INT)
		pin = std::make_shared<EditorIntPin>();
	else if (type == EditorPinType::INT2)
		pin = std::make_shared<EditorInt2Pin>();
	else if (type == EditorPinType::INT3)
		pin = std::make_shared<EditorInt3Pin>();
	else if (type == EditorPinType::INT4)
		pin = std::make_shared<EditorInt4Pin>();
	else
		pin = std::make_shared<EditorPin>();
	return pin;
}

EditorProgramNodePtr NodeEditorWindow::CreateProgramNodePtr(int progId, const ImVec2& pos)
{
	GlProgramPtr pProgram = m_Programs[progId];

	EditorProgramNodePtr node = std::make_shared<EditorProgramNode>();
	node->type = EditorNodeType::PROGRAM;
	node->nodePos = {pos.x, pos.y};
	node->target = pProgram;
	node->framebuffer = m_Framebuffers.size() > 0 ? m_Framebuffers[0] : GlFrameBufferPtr();

	// Flow in & out
	{
		EditorPinPtr pinIn = std::make_shared<EditorPin>();
		pinIn->id = (int)m_Pins.size();
		pinIn->ownerNode = node;
		pinIn->type = EditorPinType::FLOW;
		node->pinsIn.push_back(pinIn);
		node->flowIn = pinIn;
		m_Pins.push_back(pinIn);

		EditorPinPtr pinOut = std::make_shared<EditorPin>();
		pinOut->id = (int)m_Pins.size();
		pinOut->ownerNode = node;
		pinOut->type = EditorPinType::FLOW;
		pinOut->isOutput = true;
		node->pinsOut.push_back(pinOut);
		node->flowOut = pinOut;
		m_Pins.push_back(pinOut);
	}

	// Uniforms
	for (auto uniform : pProgram->GetUniforms())
	{
		EditorPinPtr pin = AllocPin(uniform.var);
		pin->id = (int)m_Pins.size();
		pin->ownerNode = node;
		pin->name = uniform.var.GetName();
		pin->type = EditorNodeUtil::GLTypeToPinType(uniform.var.GetType());
		node->pinsIn.push_back(pin);
		m_Pins.push_back(pin);
		if (pin->type == EditorPinType::IMAGE)
		{
			EditorPinPtr pinOut = std::make_shared<EditorPin>();
			pinOut->id = (int)m_Pins.size();
			pinOut->ownerNode = node;
			pinOut->name = uniform.var.GetName();
			pinOut->type = EditorPinType::IMAGE;
			pinOut->isOutput = true;
			node->pinsOut.push_back(pinOut);
			node->attachmentsPinsStartId++;
			m_Pins.push_back(pinOut);
		}
	}

	// Uniform blocks
	int index = 0;
	for (const GlUniformBlock& uniformBlock : pProgram->GetUniformBlocks())
	{
		EditorBlockPinPtr pin = std::make_shared<EditorBlockPin>();
		pin->id = (int)m_Pins.size();
		pin->ownerNode = node;
		pin->name = uniformBlock.GetName();
		pin->type = EditorPinType::BLOCK;
		pin->blockPinType = EditorBlockPinType::UNIFROM_BLOCK;
		pin->index = index++;
		pin->size = uniformBlock.size();
		node->pinsIn.push_back(pin);
		m_Pins.push_back(pin);
	}

	// Buffer blocks
	index = 0;
	for (const GlBufferBlock& bufferBlock : pProgram->GetBufferBlocks())
	{
		EditorBlockPinPtr pin = std::make_shared<EditorBlockPin>();
		pin->id = (int)m_Pins.size();
		pin->ownerNode = node;
		pin->name = bufferBlock.GetName();
		pin->type = EditorPinType::BLOCK;
		pin->blockPinType = EditorBlockPinType::BUFFER_BLOCK;
		pin->index = index;
		pin->size = bufferBlock.size();
		node->pinsIn.push_back(pin);
		m_Pins.push_back(pin);

		EditorBlockPinPtr pinOut = std::make_shared<EditorBlockPin>();
		pinOut->id = (int)m_Pins.size();
		pinOut->ownerNode = node;
		pinOut->name = bufferBlock.GetName();
		pinOut->type = EditorPinType::BLOCK;
		pinOut->blockPinType = EditorBlockPinType::BUFFER_BLOCK;
		pinOut->index = index++;
		pinOut->size = bufferBlock.size();
		pinOut->isOutput = true;
		node->pinsOut.push_back(pinOut);
		node->attachmentsPinsStartId++;
		m_Pins.push_back(pinOut);
	}

	return node;
}

void NodeEditorWindow::CreateProgramNode(int progId, const ImVec2& pos)
{
	auto node = CreateProgramNodePtr(progId, pos);
	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::PROGRAM_NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}

void NodeEditorWindow::UpdateProgramNode(int nodeId, int progId)
{
	// Create new node
	ImVec2 pos = {m_Nodes[nodeId]->nodePos.x, m_Nodes[nodeId]->nodePos.y};
	auto node = CreateProgramNodePtr(progId, pos);
	node->id = nodeId;

	// Restore attributes
	EditorProgramNodePtr nodeOld = std::static_pointer_cast<EditorProgramNode>(m_Nodes[nodeId]);
	auto iter = std::find(m_Framebuffers.begin(), m_Framebuffers.end(), nodeOld->framebuffer);
	if (iter != m_Framebuffers.end())
	{
		int index = iter - m_Framebuffers.begin();
		SetProgramNodeFramebuffer(node, index);
	}
	node->dispatchType = nodeOld->dispatchType;
	node->drawMode = nodeOld->drawMode;
	node->dispatchSize[0] = nodeOld->dispatchSize[0];
	node->dispatchSize[1] = nodeOld->dispatchSize[1];
	node->dispatchSize[2] = nodeOld->dispatchSize[2];

	// Restore pins and links
	for (int i = 0; i < node->pinsIn.size(); i++)
	{
		if (i < nodeOld->pinsIn.size() &&
			nodeOld->pinsIn[i]->type == node->pinsIn[i]->type &&
			nodeOld->pinsIn[i]->size == node->pinsIn[i]->size)
		{
			if (node->pinsIn[i]->type == EditorPinType::FLOAT)
			{
				auto newPin = std::static_pointer_cast<EditorFloatPin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorFloatPin>(nodeOld->pinsIn[i]);
				newPin->value = oldPin->value;
			}
			else if (node->pinsIn[i]->type == EditorPinType::FLOAT2)
			{
				auto newPin = std::static_pointer_cast<EditorFloat2Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorFloat2Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
			}
			else if (node->pinsIn[i]->type == EditorPinType::FLOAT3)
			{
				auto newPin = std::static_pointer_cast<EditorFloat3Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorFloat3Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
				newPin->value[2] = oldPin->value[2];
			}
			else if (node->pinsIn[i]->type == EditorPinType::FLOAT4)
			{
				auto newPin = std::static_pointer_cast<EditorFloat4Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorFloat4Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
				newPin->value[2] = oldPin->value[2];
				newPin->value[3] = oldPin->value[3];
			}
			else if (node->pinsIn[i]->type == EditorPinType::INT)
			{
				auto newPin = std::static_pointer_cast<EditorIntPin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorIntPin>(nodeOld->pinsIn[i]);
				newPin->value = oldPin->value;
			}
			else if (node->pinsIn[i]->type == EditorPinType::INT2)
			{
				auto newPin = std::static_pointer_cast<EditorInt2Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorInt2Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
			}
			else if (node->pinsIn[i]->type == EditorPinType::INT3)
			{
				auto newPin = std::static_pointer_cast<EditorInt3Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorInt3Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
				newPin->value[2] = oldPin->value[2];
			}
			else if (node->pinsIn[i]->type == EditorPinType::INT4)
			{
				auto newPin = std::static_pointer_cast<EditorInt4Pin>(node->pinsIn[i]);
				auto oldPin = std::static_pointer_cast<EditorInt4Pin>(nodeOld->pinsIn[i]);
				newPin->value[0] = oldPin->value[0];
				newPin->value[1] = oldPin->value[1];
				newPin->value[2] = oldPin->value[2];
				newPin->value[3] = oldPin->value[3];
			}

			for (auto& link : nodeOld->pinsIn[i]->connectedLinks)
			{
				if (link->pPin1 == nodeOld->pinsIn[i])
					link->pPin1 = node->pinsIn[i];
				if (link->pPin2 == nodeOld->pinsIn[i])
					link->pPin2 = node->pinsIn[i];
				node->pinsIn[i]->connectedLinks.push_back(link);
			}
			std::vector<EditorLinkPtr>().swap(nodeOld->pinsIn[i]->connectedLinks);
		}
	}
	for (int i = 0; i < node->pinsOut.size(); i++)
	{
		if (i < nodeOld->pinsOut.size() &&
			nodeOld->pinsOut[i]->type == node->pinsOut[i]->type &&
			nodeOld->pinsOut[i]->size == node->pinsOut[i]->size)
		{
			for (auto& link : nodeOld->pinsOut[i]->connectedLinks)
			{
				if (link->pPin1 == nodeOld->pinsOut[i])
					link->pPin1 = node->pinsOut[i];
				if (link->pPin2 == nodeOld->pinsOut[i])
					link->pPin2 = node->pinsOut[i];
				node->pinsOut[i]->connectedLinks.push_back(link);
			}
			std::vector<EditorLinkPtr>().swap(nodeOld->pinsOut[i]->connectedLinks);
		}
	}

	// Replace the old with the new one
	DeleteNodePinsAndLinks(nodeId);
	m_Nodes[nodeId].reset();
	m_Nodes[nodeId] = node;
}

void NodeEditorWindow::SetProgramNodeFramebuffer(EditorProgramNodePtr node, int framebufferId)
{
	int outPinId = 0;
	auto& pinsOut = node->pinsOut;
	bool needsUpdate = false;
	for (auto& outPin : pinsOut)
	{
		if (outPin->type == EditorPinType::TEXTURE)
		{
			DeletePin(outPin);
			node->pinsOut.erase(node->pinsOut.begin() + outPinId);
			outPinId--;
			needsUpdate = true;
		}
		outPinId++;
	}
	if (needsUpdate)
	{
		UpdatePins();
		UpdateLinks();
	}

	GlFrameBufferPtr framebuffer = m_Framebuffers[framebufferId];
	for (int i = 0; i < framebuffer->getNumAttachments(); i++)
	{
		EditorPinPtr pin = std::make_shared<EditorPin>();
		pin->name = "Attachment " + std::to_string(i);
		pin->id = (int)m_Pins.size();
		pin->isOutput = true;
		pin->type = EditorPinType::TEXTURE;
		pin->ownerNode = node;
		node->pinsOut.push_back(pin);
		m_Pins.push_back(pin);
	}
	node->framebuffer = framebuffer;
}

void NodeEditorWindow::CreateBlockNode(const ImVec2& pos, int pinId)
{
	EditorBlockNodePtr blockNode = std::make_shared<EditorBlockNode>();
	blockNode->type = EditorNodeType::BLOCK;
	blockNode->nodePos = {pos.x, pos.y};

	int size = 0;
	if (pinId != -1)
	{
		EditorBlockPinPtr progPin = std::static_pointer_cast<EditorBlockPin>(m_Pins[pinId]);
		EditorProgramNodePtr progNode = std::static_pointer_cast<EditorProgramNode>(progPin->ownerNode);
		if (progPin->blockPinType == EditorBlockPinType::UNIFROM_BLOCK)
		{
			const GlUniformBlock& block = progNode->target->GetUniformBlocks()[progPin->index];
			for (auto& uniform : block.GetUniforms())
			{
				EditorPinPtr pin = AllocPin(uniform.var);
				pin->id = (int)m_Pins.size();
				pin->ownerNode = blockNode;
				pin->name = uniform.var.GetName();
				pin->type = EditorNodeUtil::GLTypeToPinType(uniform.var.GetType());
				blockNode->pinsIn.push_back(pin);
				m_Pins.push_back(pin);
				size += EditorNodeUtil::PinTypeSize(pin->type);
			}
		}
		else
		{
			const GlBufferBlock& block = progNode->target->GetBufferBlocks()[progPin->index];
			for (auto& var : block.GetVars())
			{
				EditorPinPtr pin = AllocPin(var);
				pin->id = (int)m_Pins.size();
				pin->ownerNode = blockNode;
				pin->name = var.GetName();
				pin->type = EditorNodeUtil::GLTypeToPinType(var.GetType());
				blockNode->pinsIn.push_back(pin);
				m_Pins.push_back(pin);
				size += EditorNodeUtil::PinTypeSize(pin->type);
			}
		}
	}

	EditorPinPtr pin = std::make_shared<EditorBlockPin>();
	pin->id = (int)m_Pins.size();
	pin->ownerNode = blockNode;
	pin->name = "";
	pin->type = EditorPinType::BLOCK;
	pin->isOutput = true;
	pin->size = size;
	blockNode->pinsOut.push_back(pin);
	m_Pins.push_back(pin);
	if (pinId != -1)
	{
		if (m_Pins[pinId]->connectedLinks.size() > 0)
		{
			DeleteLink(m_Pins[pinId]->connectedLinks[0]->id);
			UpdateLinks();
		}
		CreateLink((int)m_Pins.size() - 1, pinId);
	}

	blockNode->id = (int)m_Nodes.size();
	blockNode->size = size;

	glGenBuffers(1, &blockNode->ubo);
	glBindBuffer(GL_UNIFORM_BUFFER, blockNode->ubo);
	glBufferData(GL_UNIFORM_BUFFER, blockNode->size, NULL, GL_DYNAMIC_DRAW);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
	glGenBuffers(1, &blockNode->ssbo);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, blockNode->ssbo);
	glBufferData(GL_SHADER_STORAGE_BUFFER, blockNode->size * blockNode->ssboSize, NULL, GL_DYNAMIC_DRAW);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);

	m_Nodes.push_back(blockNode);

	ImNodes::SetNodeScreenSpacePos(blockNode->id, pos);

	m_SelectedItemType = SelectedItemType::BUFFER_NODE;
	m_SelectedItemId = blockNode->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(blockNode->id);
}

void NodeEditorWindow::CreateTextureNode(int textureId, const ImVec2& pos)
{
	EditorTextureNodePtr node = std::make_shared<EditorTextureNode>();
	node->type = EditorNodeType::TEXTURE;
	node->nodePos = {pos.x, pos.y};
	node->target = m_Textures[textureId];

	EditorPinPtr pin = std::make_shared<EditorPin>();
	pin->id = (int)m_Pins.size();
	pin->ownerNode = node;
	pin->name = "";
	pin->type = EditorPinType::TEXTURE;
	pin->isOutput = true;
	node->pinsOut.push_back(pin);
	m_Pins.push_back(pin);

	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}

void NodeEditorWindow::CreateImageNode(const ImVec2& pos)
{
	EditorImageNodePtr node = std::make_shared<EditorImageNode>();
	node->type = EditorNodeType::IMAGE;
	node->nodePos = {pos.x, pos.y};

	EditorPinPtr pinIn = std::make_shared<EditorPin>();
	pinIn->name = "Texture";
	pinIn->ownerNode = node;
	pinIn->type = EditorPinType::TEXTURE;
	pinIn->id = (int)m_Pins.size();
	node->pinsIn.push_back(pinIn);
	m_Pins.push_back(pinIn);

	EditorPinPtr pinOut1 = std::make_shared<EditorPin>();
	pinOut1->name = "";
	pinOut1->ownerNode = node;
	pinOut1->type = EditorPinType::IMAGE;
	pinOut1->isOutput = true;
	pinOut1->id = (int)m_Pins.size();
	node->pinsOut.push_back(pinOut1);
	m_Pins.push_back(pinOut1);

	EditorPinPtr pinOut2 = std::make_shared<EditorPin>();
	pinOut2->name = "";
	pinOut2->ownerNode = node;
	pinOut2->type = EditorPinType::TEXTURE;
	pinOut2->isOutput = true;
	pinOut2->id = (int)m_Pins.size();
	node->pinsOut.push_back(pinOut2);
	m_Pins.push_back(pinOut2);

	glGenTextures(1, &node->texture);
	glBindTexture(GL_TEXTURE_2D, node->texture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 0, 0, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
	glBindTexture(GL_TEXTURE_2D, 0);

	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::IMAGE_NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}

void NodeEditorWindow::CreatePingPongNode(const ImVec2& pos, EditorPingPongNodeType type)
{
	EditorPingPongNodePtr node = std::make_shared<EditorPingPongNode>();
	node->type = EditorNodeType::PINGPONG;
	node->nodePos = {pos.x, pos.y};
	node->pingpongType = type;

	EditorPinPtr pinIn1 = std::make_shared<EditorPin>();
	pinIn1->id = (int)m_Pins.size();
	pinIn1->ownerNode = node;
	pinIn1->name = "Buffer A";
	if (type == EditorPingPongNodeType::BUFFER)
	{
		pinIn1->type = EditorPinType::BLOCK;
		pinIn1->size = 0;
	}
	else
	{
		pinIn1->type = EditorPinType::IMAGE;
		pinIn1->size = 1;
	}
	node->pinsIn.push_back(pinIn1);
	m_Pins.push_back(pinIn1);

	EditorPinPtr pinIn2 = std::make_shared<EditorPin>();
	pinIn2->id = (int)m_Pins.size();
	pinIn2->ownerNode = node;
	pinIn2->name = "Buffer B";
	if (type == EditorPingPongNodeType::BUFFER)
	{
		pinIn2->type = EditorPinType::BLOCK;
		pinIn2->size = 0;
	}
	else
	{
		pinIn2->type = EditorPinType::IMAGE;
		pinIn2->size = 1;
	}
	node->pinsIn.push_back(pinIn2);
	m_Pins.push_back(pinIn2);

	EditorPinPtr pinOut1 = std::make_shared<EditorPin>();
	pinOut1->id = (int)m_Pins.size();
	pinOut1->ownerNode = node;
	pinOut1->name = "Out 1";
	if (type == EditorPingPongNodeType::BUFFER)
	{
		pinOut1->type = EditorPinType::BLOCK;
		pinOut1->size = 0;
	}
	else
	{
		pinOut1->type = EditorPinType::IMAGE;
		pinOut1->size = 1;
	}
	pinOut1->isOutput = true;
	node->pinsOut.push_back(pinOut1);
	m_Pins.push_back(pinOut1);

	EditorPinPtr pinOut2 = std::make_shared<EditorPin>();
	pinOut2->id = (int)m_Pins.size();
	pinOut2->ownerNode = node;
	pinOut2->name = "Out 2";
	if (type == EditorPingPongNodeType::BUFFER)
	{
		pinOut2->type = EditorPinType::BLOCK;
		pinOut2->size = 0;
	}
	else
	{
		pinOut2->type = EditorPinType::IMAGE;
		pinOut2->size = 1;
	}
	pinOut2->isOutput = true;
	node->pinsOut.push_back(pinOut2);
	m_Pins.push_back(pinOut2);

	if (type == EditorPingPongNodeType::BUFFER)
		node->size = 0;
	else
		node->size = 1;

	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::PINGPONG_NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}

void NodeEditorWindow::UpdatePingPongNode(int nodeId, EditorPingPongNodeType type)
{
	EditorPingPongNodePtr node = std::static_pointer_cast<EditorPingPongNode>(m_Nodes[nodeId]);

	for (auto& pin : node->pinsIn)
	{
		for (auto& link : pin->connectedLinks)
			DeleteLink(link->id);
		if (type == EditorPingPongNodeType::BUFFER)
		{
			pin->type = EditorPinType::BLOCK;
			pin->size = 0;
		}
		else
		{
			pin->type = EditorPinType::IMAGE;
			pin->size = 1;
		}
	}
	for (auto& pin : node->pinsOut)
	{
		for (auto& link : pin->connectedLinks)
			DeleteLink(link->id);
		if (type == EditorPingPongNodeType::BUFFER)
		{
			pin->type = EditorPinType::BLOCK;
			pin->size = 0;
		}
		else
		{
			pin->type = EditorPinType::IMAGE;
			pin->size = 1;
		}
	}
	UpdateLinks();

	node->pingpongType = type;
	if (type == EditorPingPongNodeType::BUFFER)
		node->size = 0;
	else
		node->size = 1;
}

void NodeEditorWindow::CreateTimeNode(const ImVec2& pos)
{
	EditorNodePtr node = std::make_shared<EditorNode>();
	node->type = EditorNodeType::TIME;
	node->nodePos = {pos.x, pos.y};

	EditorPinPtr pin = std::make_shared<EditorPin>();
	pin->ownerNode = node;
	pin->type = EditorPinType::FLOAT;
	pin->isOutput = true;
	pin->id = (int)m_Pins.size();
	node->pinsOut.push_back(pin);
	m_Pins.push_back(pin);

	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}

void NodeEditorWindow::CreateMousePosNode(const ImVec2& pos)
{
	EditorNodePtr node = std::make_shared<EditorNode>();
	node->type = EditorNodeType::MOUSE_POS;
	node->nodePos = {pos.x, pos.y};

	EditorPinPtr pin = std::make_shared<EditorPin>();
	pin->ownerNode = node;
	pin->type = EditorPinType::FLOAT2;
	pin->isOutput = true;
	pin->id = (int)m_Pins.size();
	node->pinsOut.push_back(pin);
	m_Pins.push_back(pin);

	node->id = (int)m_Nodes.size();
	m_Nodes.push_back(node);

	ImNodes::SetNodeScreenSpacePos(node->id, pos);

	m_SelectedItemType = SelectedItemType::NODE;
	m_SelectedItemId = node->id;
	ImNodes::ClearLinkSelection();
	ImNodes::ClearNodeSelection();
	ImNodes::SelectNode(node->id);
}
