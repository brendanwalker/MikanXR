//-- includes -----
#include "CompositorNodeEditorWindow.h"
#include "GlTexture.h"
#include "GlTriangulatedMesh.h"
#include "Delegate.h"
#include "Logger.h"

#include "Graphs/CompositorNodeGraph.h"
#include "Nodes/Node.h"
#include "Nodes/DrawTriMeshNode.h"
#include "Nodes/TextureNode.h"
#include "Pins/NodePin.h"
#include "Properties/GraphArrayProperty.h"

// Autogenerated header containing Unicode Icon IDs from "forkawesome-webfont.ttf"
#include "IconsForkAwesome.h"

#include "tinyfiledialogs.h" // Cross-platform file dialogs library

CompositorNodeEditorWindow::CompositorNodeEditorWindow() : NodeEditorWindow()
{
}

CompositorNodeEditorWindow::~CompositorNodeEditorWindow()
{
}

void CompositorNodeEditorWindow::update(float deltaSeconds)
{
	NodeEditorWindow::update(deltaSeconds);
}

NodeGraphPtr CompositorNodeEditorWindow::allocateNodeGraph()
{
	return std::make_shared<CompositorNodeGraph>();
}

void CompositorNodeEditorWindow::onNodeGraphCreated()
{
	NodeEditorWindow::onNodeGraphCreated();

	m_triMeshArrayProperty = m_nodeGraph->getTypedPropertyByName<TriMeshArrayProperty>("triangulatedMeshes");
	m_textureArrayProperty = m_nodeGraph->getTypedPropertyByName<TextureArrayProperty>("textures");
}

void CompositorNodeEditorWindow::onNodeGraphDeleted()
{
	m_triMeshArrayProperty= nullptr;
	m_textureArrayProperty= nullptr;

	NodeEditorWindow::onNodeGraphDeleted();
}

void CompositorNodeEditorWindow::renderToolbar()
{
	ImGui::PushFont(m_BigIconFont);

	ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 4));
	ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0);
	ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
	ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.0f, 0.0f, 0.0f, 0.5f));

	ImGui::BeginChild("Toolbar", ImVec2(ImGui::GetContentRegionAvail().x, 40));

	ImGui::SetCursorPosY((ImGui::GetWindowHeight() - 30) * 0.5f);
	if (ImGui::Button(ICON_FK_FLOPPY_O "   Save", ImVec2(0, 30)))
	{
		// TODO 
	}

	// Editor Control
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 4.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 4));
		ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.2f, 0.2f, 1.0f));

		ImGui::SameLine();
		ImGui::BeginChild("EditorControl", ImVec2(70, 30), true, ImGuiWindowFlags_NoScrollbar);
		ImGui::SetCursorPosY((ImGui::GetWindowHeight() - ImGui::GetTextLineHeight()) * 0.5f);

		if (m_IsPlaying)
		{
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.3f, 0.3f, 1.0f));
			if (ImGui::SmallButton(ICON_FK_STOP))
				m_IsPlaying = false;
		}
		else
		{
			ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 0.8f, 0.5f, 1.0f));
			if (ImGui::SmallButton(ICON_FK_PLAY))
			{
				m_OnInit = true;
				m_IsPlaying = true;
			}
		}
		ImGui::PopStyleColor();

		ImGui::SameLine();
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
		if (ImGui::SmallButton(ICON_FK_UNDO))
			m_OnInit = true;
		ImGui::PopStyleColor();

		ImGui::EndChild();
		ImGui::PopStyleColor(3);
		ImGui::PopStyleVar(2);
	}

	ImGui::EndChild();

	ImGui::PopStyleVar(3);
	ImGui::PopStyleColor(4);

	ImGui::PopFont();
}

void CompositorNodeEditorWindow::renderLeftPanel()
{
	ImGui::BeginChild("Left Panel", ImVec2(200, ImGui::GetContentRegionAvail().y));

	// Triangulated Meshes
	{
		auto& triMeshArray = m_triMeshArrayProperty->getArray();

		// Add button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(180);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##add_tri_mesh"))
		{
			ImNodes::ClearLinkSelection();
			ImNodes::ClearNodeSelection();

			//TODO: Allocate empty triangulated mesh
			std::string name = "Tri Mesh: " + std::to_string(triMeshArray.size() + 1);
			//AddTriangulatedMesh(m_shaderCache->allocateEmptyGlProgram(name));

			m_SelectedItemType = SelectedItemType::TRI_MESH;
			m_SelectedItemId = (int)triMeshArray.size() - 1;
		}
		ImGui::SameLine();
		ImGui::SetCursorPosX(xPos);

		// Title bar
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("TRIANGULATED MESHES", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::SameLine();
		ImGui::SetCursorPosX(180);
		ImGui::Text(ICON_FK_PLUS_CIRCLE);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			for (int i = 0; i < triMeshArray.size(); i++)
			{
				// Item
				std::string name = "\t\t" + triMeshArray[i]->getName();
				name += "##trimesh" + std::to_string(i);
				bool isSelected = m_SelectedItemType == SelectedItemType::TRI_MESH;
				isSelected = isSelected && (m_SelectedItemId == i);
				if (ImGui::Selectable(name.c_str(), &isSelected))
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					if (isSelected)
					{
						m_SelectedItemType = SelectedItemType::TRI_MESH;
						m_SelectedItemId = i;
					}
					else
					{
						m_SelectedItemType = SelectedItemType::NONE;
						m_SelectedItemId = -1;
					}
				}
				if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
				{
					ImGui::SetDragDropPayload("tri_mesh", &i, sizeof(int));
					ImGui::Text(triMeshArray[i]->getName().c_str());
					ImGui::EndDragDropSource();
				}

				// Context menu
				ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
				ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
				ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
				ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
				ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
				if (ImGui::BeginPopupContextItem())
				{
					ImNodes::ClearLinkSelection();
					ImNodes::ClearNodeSelection();
					m_SelectedItemType = SelectedItemType::TRI_MESH;
					m_SelectedItemId = i;

					if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						deleteSelectedItem();

					ImGui::EndPopup();
				}
				ImGui::PopStyleColor(2);
				ImGui::PopStyleVar(3);
			}
			ImGui::PopStyleColor();
		}
	}

	ImGui::EndChild();
}

void CompositorNodeEditorWindow::renderRightPanel()
{
	ImGui::SameLine();
	ImGui::BeginChild("Right Panel", ImVec2(344, ImGui::GetContentRegionAvail().y));

	if (m_SelectedItemType == SelectedItemType::NODE)
	{
		NodePtr node = m_nodeGraph->getNodeById(m_SelectedItemId);

		if (node)
		{
			node->editorRenderPropertySheet(m_editorState);
		}
	}
	else if (m_SelectedItemType == SelectedItemType::TEXTURE)
	{
		//TODO
	}
	else if (m_SelectedItemType == SelectedItemType::TRI_MESH)
	{
		// Section 1: Basic info
		ImGui::SetNextItemOpen(true, ImGuiCond_Once);
		ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 4));
		ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 0.0f);
		ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 0.0f);
		ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.4f, 0.4f, 0.4f, 1.0f));
		bool isNodeOpened = ImGui::CollapsingHeader("Tri Mesh", ImGuiTreeNodeFlags_SpanAvailWidth);
		ImGui::PopStyleVar(3);
		ImGui::PopStyleColor(3);

		if (isNodeOpened)
		{
			// Name
			ImGui::Text("\t\tName");
			ImGui::SameLine(160);
			ImGui::SetNextItemWidth(150);
			GlTriangulatedMeshPtr triMesh = m_triMeshArrayProperty->getArray()[m_SelectedItemId];
			std::string name = triMesh->getName();
			ImGui::Text(name.c_str());
		}

		// Section 2: Shaders
		// Add Button
		float xPos = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(325);
		if (ImGui::SmallButton(ICON_FK_PLUS_CIRCLE "##set_mesh"))
		{
		#if 0
			auto paths_c = tinyfd_openFileDialog("Add Shader", "", 0, 0, 0, 1);
			if (paths_c)
			{
				std::stringstream ssPaths(paths_c);
				std::string path;
				while (std::getline(ssPaths, path, '|'))
					m_Programs[m_SelectedItemId]->AddShader(
						PathUtils::makeUniversalPathString(path).c_str(),
						GL_VERTEX_SHADER);
			}
		#endif
		}
	}

	ImGui::EndChild();
}

void CompositorNodeEditorWindow::renderBottomPanel()
{
	ImGui::BeginChild("Bottom Panel", ImVec2(ImGui::GetContentRegionAvail().x, 216));
	if (ImGui::BeginTabBar("BottomTabBar"))
	{
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
		if (ImGui::BeginTabItem("Textures"))
		{
			ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.25f, 0.25f, 0.25f, 0.4f));
			ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(0.13f, 0.13f, 0.13f, 1.0f));
			ImGui::BeginChild("TexturesSubFrame");

			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPos().x + 6, ImGui::GetCursorPos().y + 6));
			if (ImGui::ImageButton("  Add##tex", ICON_FK_PLUS, ImVec2(70, 25), ImVec2(0.4f, 0.8f), ImVec2(0.4f, 1.0f)))
			{
				const char* filterItems[5] = {"*.jpg", "*.jpeg", "*.png", "*.bmp", "*.tga"};
				const char* filterDesc = "Image Files (*.jpg;*.jpeg;*.png;*.bmp;*.tga)";
				auto paths_c = tinyfd_openFileDialog("Load Texture", "", 5, filterItems, filterDesc, 1);
				if (paths_c)
				{
					std::stringstream ssPaths(paths_c);
					std::string path;
					while (std::getline(ssPaths, path, '|'))
					{
						std::string universalPath(path);
						std::replace(universalPath.begin(), universalPath.end(), '\\', '/');

						GlTexturePtr tex = std::make_shared<GlTexture>();
						tex->setImagePath(universalPath);

						if (tex->reloadTextureFromImagePath())
						{
							addTexture(tex);
						}
					}
				}
			}

			ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 6);
			ImGui::Separator();

			// Textures browser
			{
				auto& textureArray = m_textureArrayProperty->getArray();

				ImGui::BeginChild("TextureBrowser");

				ImGui::Dummy(ImVec2(1, 10));
				for (int i = 0; i < textureArray.size(); i++)
				{
					ImGui::Dummy(ImVec2(10, 140));
					ImGui::SameLine();
					ImGui::BeginGroup();
					std::string idStr = "##texture" + std::to_string(i);
					ImGui::Button(idStr.c_str(), ImVec2(120, 140));

					if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
					{
						ImGui::SetDragDropPayload("texture", &i, sizeof(int));
						ImGui::Text(textureArray[i]->getName().c_str());
						ImGui::EndDragDropSource();
					}

					// Context menu
					bool itemDeleted = false;
					ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(4, 4));
					ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 6));
					ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(14, 4));
					ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.1f, 0.4f, 0.9f, 1.0f));
					ImGui::PushStyleColor(ImGuiCol_PopupBg, ImVec4(0.25f, 0.25f, 0.25f, 1.0f));
					if (ImGui::BeginPopupContextItem())
					{
						ImNodes::ClearLinkSelection();
						ImNodes::ClearNodeSelection();
						m_SelectedItemType = SelectedItemType::TEXTURE;
						m_SelectedItemId = i;

						if (ImGui::MenuItem("Delete", ICON_FK_TRASH, "DELETE"))
						{
							deleteSelectedItem();
							itemDeleted = true;
						}

						ImGui::EndPopup();
					}
					ImGui::PopStyleColor(2);
					ImGui::PopStyleVar(3);

					if (!itemDeleted)
					{
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10);
						ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 130);
						ImGui::Image((void*)(intptr_t)textureArray[i]->getGlTextureId(), ImVec2(100, 100));
						ImGui::Dummy(ImVec2(2, 1));
						ImGui::SameLine();
						ImGui::SetNextItemWidth(108);
						ImGui::Text(textureArray[i]->getName().c_str());
					}
					ImGui::EndGroup();

					ImGui::SameLine();
					if (ImGui::GetContentRegionAvail().x < 130)
					{
						ImGui::NewLine();
						ImGui::NewLine();
					}
				}
				ImGui::NewLine();
				ImGui::Dummy(ImVec2(1, 10));

				ImGui::EndChild();
			}

			ImGui::EndChild();
			ImGui::PopStyleColor();
			ImGui::PopStyleColor();
			ImGui::EndTabItem();
		}
		ImGui::PopStyleVar();
		ImGui::EndTabBar();
	}
	ImGui::EndChild();
}

void CompositorNodeEditorWindow::renderDragDrop(const class NodeEditorState& editorState)
{
	if (auto payload = ImGui::AcceptDragDropPayload("tri_mesh"))
	{
		IM_ASSERT(payload->DataSize == sizeof(GlTriangulatedMeshPtr*));
		GlTriangulatedMeshPtr triangulatedMesh = *(GlTriangulatedMeshPtr*)payload->Data;

		auto triMeshNode =
			std::static_pointer_cast<DrawTriMeshNode>(
				DrawTriMeshNodeFactory(m_nodeGraph).createNode(&editorState));
		triMeshNode->setTriangulatedMesh(triangulatedMesh);
	}
	else if (auto payload = ImGui::AcceptDragDropPayload("texture"))
	{
		IM_ASSERT(payload->DataSize == sizeof(GlTexturePtr*));
		GlTexturePtr texture = *(GlTexturePtr*)payload->Data;

		auto textureNode =
			std::static_pointer_cast<TextureNode>(
				TextureNodeFactory(m_nodeGraph).createNode(&editorState));
		textureNode->setTexture(texture);
	}
}

void CompositorNodeEditorWindow::deleteSelectedItem()
{
	NodeEditorWindow::deleteSelectedItem();

	if (m_SelectedItemType == SelectedItemType::TRI_MESH)
	{
		deleteTriangulatedMesh(m_SelectedItemId);

		m_SelectedItemType = SelectedItemType::NONE;
		m_SelectedItemId = -1;
	}
	else if (m_SelectedItemType == SelectedItemType::TEXTURE)
	{
		deleteTexture(m_SelectedItemId);

		m_SelectedItemType = SelectedItemType::NONE;
		m_SelectedItemId = -1;
	}
}

void CompositorNodeEditorWindow::addTriangulatedMesh(GlTriangulatedMeshPtr triMesh)
{
	if (m_triMeshArrayProperty)
	{
		m_triMeshArrayProperty->getArrayMutable().push_back(triMesh);
		m_triMeshArrayProperty->notifyPropertyModified();
	}
}

void CompositorNodeEditorWindow::deleteTriangulatedMesh(int ix)
{
	if (m_triMeshArrayProperty)
	{
		auto triMeshArray = m_triMeshArrayProperty->getArrayMutable();

		if (ix >= 0 && ix < (int)triMeshArray.size())
		{
			triMeshArray.erase(triMeshArray.begin() + ix);
			m_triMeshArrayProperty->notifyPropertyModified();
		}
	}
}

void CompositorNodeEditorWindow::addTexture(GlTexturePtr pTex)
{
	if (m_textureArrayProperty)
	{
		m_textureArrayProperty->getArrayMutable().push_back(pTex);
		m_textureArrayProperty->notifyPropertyModified();
	}
}

void CompositorNodeEditorWindow::deleteTexture(int ix)
{
	if (m_textureArrayProperty)
	{
		auto textureArray = m_textureArrayProperty->getArrayMutable();

		if (ix >= 0 && ix < (int)textureArray.size())
		{
			textureArray.erase(textureArray.begin() + ix);
			m_textureArrayProperty->notifyPropertyModified();
		}
	}
}