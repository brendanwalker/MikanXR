#include "Graphs/NodeGraph.h"
#include "Nodes/ArrayNode.h"
#include "Pins/ArrayPin.h"
#include "Pins/PropertyPin.h"
#include "Pins/NodeLink.h"
#include "Properties/GraphProperty.h"

// Autogenerated header containing Unicode Icon IDs from "forkawesome-webfont.ttf"
#include "IconsForkAwesome.h"

#include "StringUtils.h"

// -- ArrayNode Config -----
configuru::Config ArrayNodeConfig::writeToJSON()
{
	configuru::Config pt = NodeConfig::writeToJSON();

	pt["element_class_name"] = elementClassName;

	return pt;
}

void ArrayNodeConfig::readFromJSON(const configuru::Config& pt)
{
	NodeConfig::readFromJSON(pt);

	elementClassName = pt.get_or<std::string>("element_class_name", "");
}

// -- EventNode -----
bool ArrayNode::loadFromConfig(NodeConfigConstPtr nodeConfig)
{
	if (Node::loadFromConfig(nodeConfig))
	{
		auto arrayNodeConfig = std::static_pointer_cast<const ArrayNodeConfig>(nodeConfig);

		m_elementClassName= arrayNodeConfig->elementClassName;

		// Rebuild output value now that all input pins are loaded
		rebuildOutputArrayValue();

		return true;
	}

	return false;
}

void ArrayNode::saveToConfig(NodeConfigPtr nodeConfig) const
{
	auto arrayNodeConfig = std::static_pointer_cast<ArrayNodeConfig>(nodeConfig);

	arrayNodeConfig->elementClassName= m_elementClassName;

	Node::saveToConfig(nodeConfig);
}

bool ArrayNode::evaluateNode(NodeEvaluator& evaluator)
{
	// Nothing to do
	return true;
}

void ArrayNode::editorRenderInputPins(const NodeEditorState& editorState)
{
	if (m_pinsIn.size() > 0)
	{
		ImGui::BeginGroup();
		for (auto& pin : m_pinsIn)
		{
			pin->editorRenderInputPin(editorState);
		}

		const std::string buttonName = StringUtils::stringify(ICON_FK_PLUS_CIRCLE, "##add_pin");
		if (ImGui::SmallButton(buttonName.c_str()))
		{
			const int pinIndex= (int)m_pinsIn.size();
			char pinName[16];

			StringUtils::formatString(pinName, sizeof(pinName), "[%d]", pinIndex);
			auto newPin= addPin<PropertyPin>(pinName, eNodePinDirection::INPUT);
			newPin->setPropertyClassName(m_elementClassName);
		}

		ImGui::EndGroup();
		ImGui::SameLine();
	}
}

void ArrayNode::onLinkConnected(NodeLinkPtr link, NodePinPtr pin)
{
	if (m_elementClassName.empty())
	{
		std::string elementClassName;

		// Output array pin got connected to?
		if (pin == m_pinsOut[0])
		{
			// Get the element class from the array pin getting connected to the output
			auto sourcePin = link->getConnectedPin(pin);
			assert(sourcePin->getClassName() == ArrayPin::k_pinClassName);
			auto sourceArrayPin = std::static_pointer_cast<ArrayPin>(sourcePin);

			elementClassName = sourceArrayPin->getElementClassName();
		}
		// Otherwise it must have been an input pin
		else
		{
			// Get the element class from the property pin getting connected to an input
			auto sourcePin = link->getConnectedPin(pin);
			assert(sourcePin->getClassName() == PropertyPin::k_pinClassName);
			auto sourcePropertyPin = std::static_pointer_cast<PropertyPin>(sourcePin);
			
			elementClassName = sourcePropertyPin->getPropertyClassName();

			// Also on input pin changes, rebuild the output array value
			rebuildOutputArrayValue();
		}

		// Make output array pin and input property pins have the same property class
		// This will make it so that all future connections have to use the same property class
		// For example, if we just connected our first StencilProperty, all future connections
		// have to also be StencilProperties.
		assert(!elementClassName.empty());
		setElementClassName(elementClassName);
	}
}

void ArrayNode::onLinkDisconnected(NodeLinkPtr link, NodePinPtr pin)
{
	if (!hasAnyConnectedPins())
	{
		// If there are no more connected pins, clear the element class on all pins.
		// This will allow property pins of a different element class to be connected.
		setElementClassName("");
	}
}

void ArrayNode::setElementClassName(const std::string inElementClassName)
{
	if (inElementClassName != m_elementClassName)
	{
		m_elementClassName= inElementClassName;

		for (const NodePinPtr& pin : m_pinsIn)
		{
			auto propPin= std::static_pointer_cast<PropertyPin>(pin);
			propPin->setPropertyClassName(inElementClassName);
		}

		assert(m_pinsOut.size() == 1);
		auto arrayPin= std::static_pointer_cast<ArrayPin>(m_pinsOut[0]);
		arrayPin->setElementClassName(inElementClassName);
	}
}

void ArrayNode::rebuildOutputArrayValue()
{
	std::vector<GraphPropertyPtr> newArrayValue;
	for (const NodePinPtr& pin : m_pinsIn)
	{
		auto propPin = std::static_pointer_cast<PropertyPin>(pin);
		GraphPropertyPtr property= propPin->getValue();

		// Only bother with non empty properties
		if (property)
		{
			newArrayValue.push_back(property);
		}
	}

	assert(m_pinsOut.size() == 1);
	auto arrayPin = std::static_pointer_cast<ArrayPin>(m_pinsOut[0]);
	arrayPin->setArray(newArrayValue);
}

// -- ArrayNode Factory -----
NodePtr ArrayNodeFactory::createNode(const NodeEditorState& editorState) const
{
	// Create the node and pins
	NodePtr node = NodeFactory::createNode(editorState);
	ArrayPinPtr outputPin = node->addPin<ArrayPin>("array", eNodePinDirection::OUTPUT);
	//NOTE: output pin has no element class assigned until we connect our first link
	// see onLinkConnected / onLinkDisconnected

	PropertyPinPtr firstInputPin = node->addPin<PropertyPin>("[0]", eNodePinDirection::INPUT);
	//NOTE: input pin has no property class assigned until we connect our first link
	// see onLinkConnected / onLinkDisconnected

	// If spawned in an editor context from a dangling pin link
	// auto-connect compatible pins
	autoConnectOutputPin(editorState, outputPin);
	autoConnectOutputPin(editorState, firstInputPin);

	return node;
}